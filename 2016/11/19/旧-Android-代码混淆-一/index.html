<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [旧]Android 代码混淆(一) · flyer</title><meta name="description" content="[旧]Android 代码混淆(一) - flyer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dove.im/atom.xml" title="flyer"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/flyer88xu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/flyer88" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">[旧]Android 代码混淆(一)</h1><div class="post-info">Nov 19, 2016</div><div class="post-content"><p>本文前半部分对照 <a href="http://proguard.sourceforge.net" target="_blank" rel="external">Proguard 文档 (Manul 中的 Introduce 部分)</a>进行翻译同时加上个人的理解，如果有与原文不同，请以原文为主。后半部分是对几个步骤的验证。</p>
<hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>混淆器(ProGuard)会对 Java class 文件进行 shrinker(压缩)，optimizer(优化)，obfuscator(混淆)以及preverifier(校验)。shrinker(压缩)这一步会找到并移除没用到的类，变量，方法，属性。optimization(优化)这一步，会分析并且优化方法的字节码。obfuscation(混淆)则会对 class，fields，methods替换成一些短的无意义的名字。第一步会把代码量变小，运行更加有效率，同时更加难以被逆向。在 Java Micro Edition 和 Java 6或者更高版本中，最后一步的检验过程，会向class文件中添加一些预校验的信息。<br>上述的每个步骤，都是可以选择的(可以进行也可以不进行)。例如，ProGuard 可以只进行preverify，从而更高效的运行。</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/21-59-04.jpg" alt=""></p>
<ul>
<li>首先，ProGuard(混淆器) 读入输入的 jars (也可以是 aars, wars, ears, zips, apks, 或者目录)。随后，开始进行 shrinker(压缩)，optimizer(优化)，obfuscator(混淆)以及preverifier(校验)。你可以选择性的让ProGuard(混淆器)进行多种类型的优化操作。ProGuard(混淆器)会把修改过的结果写入一个或者多个输出的 jars (也可以是 aars, wars, ears, zips, apks, 或者目录)中。</li>
<li>混淆器需要明确输入文件(Input jars)是jars包(也可以是 aars, wars, ears, zips, apks, 或者目录)。这些 libraries 本质上是你将会用来编译的代码。混淆器为了能够正确进行整个过程，会重新构建类之间的依赖。而依赖包(Library jars) 往往是不会被改变的，但你依旧需要把它们放在最终的App的环境中。</li>
</ul>
<h4 id="Entry-points-入口点"><a href="#Entry-points-入口点" class="headerlink" title="Entry points(入口点)"></a>Entry points(入口点)</h4><ul>
<li>在压缩步骤(shrinker)，混淆器会从这些点(入口点)进入，并且递归寻找决定哪些类和哪些类成员会被使用。所有的其他类和类成员都会被抛弃掉</li>
<li>在优化步骤(optimizer)，混淆器会进一步优化代码。在这些优化过程中，那些不是入口点的类和方法会变成private static或者final，不被用到的参数会被移除，一些方法会变成内敛方法</li>
<li>在混淆这一步(obfuscator)，混淆器会重新命名那些不是入口点的类和类的成员。在这整个过程中，那些成为入口点的地方，依旧会为他们保留原来的名字</li>
<li>预验证阶段(preverifier)是唯一一个不需要知道入口点的阶段</li>
</ul>
<h4 id="反射-该部分内容具体处理和理解，会在下一文章中进行具体的记录"><a href="#反射-该部分内容具体处理和理解，会在下一文章中进行具体的记录" class="headerlink" title="反射(该部分内容具体处理和理解，会在下一文章中进行具体的记录)"></a>反射(该部分内容具体处理和理解，会在下一文章中进行具体的记录)</h4><ul>
<li>对于反射和introspection 进行代码的自动处理时，都会存在一些特殊的问题。在混淆器进行处理时，代码中类和类成员都是被动态创建或者被动态调用的(通过对应类的名字，或者成员名字)，这些地方都必须被定义成入口点。例如，<code>Class.forName()</code>这个构造器会在运行时指向任何的类。又比如，类的名字可能会从配置文件中读入，这通常很难去计算出是那些类需要被保留(通过原始的名字)。因此，你必须得在混淆器的配置中，通过简单相同的操作<code>-keep</code>来指定他们。<br>然而，混淆器已经能够帮你发现并处理以下的情况：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Class.forName(<span class="string">"SomeClass"</span>)</div><div class="line">SomeClass.class</div><div class="line">SomeClass.class.getField(<span class="string">"someField"</span>)</div><div class="line">SomeClass.class.getDeclaredField(<span class="string">"someField"</span>)</div><div class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123;&#125;)</div><div class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class &#125;)</div><div class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class, B.class &#125;)</div><div class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123;&#125;)</div><div class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class &#125;)</div><div class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class, B.class &#125;)</div><div class="line">AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, <span class="string">"someField"</span>)</div><div class="line">AtomicLongFieldUpdater.newUpdater(SomeClass.class, <span class="string">"someField"</span>)</div><div class="line">AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, <span class="string">"someField"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>类和类成员的名字会不一样，但是构造方法必然是相同的，由此，混淆器能够认出他们。被引用的类和类的成员在压缩(shrinking)阶段会被保留，同时，string 类型的参数也会在混淆时(obfuscation)被准确的修改。</li>
<li>除此之外，混淆器会提供一些建议：是否保留一些出现的类和类成员。举例，混淆器会标记<code>(SomeClass)Class.forName(variable).newInstance()</code>这样的构造器。因为这些方法可能会指向其他类，这些可能是类，也可能是接口，或者是继承自这些接口或者类的类。你需要在配置中做相应的处理。</li>
<li>为了能够得到正确的混淆结果，你应该对进行混淆的代码多少有所熟悉。当面临大量反射代码时，混淆代码需要进行大量的试验，并处理错误，特别是对于内部代码没有足够的信息的情况下    </li>
</ul>
<hr>
<p>以上是对<a href="http://proguard.sourceforge.net" target="_blank" rel="external">官方文档首页</a>的翻译内容</p>
<h2 id="具体的验证"><a href="#具体的验证" class="headerlink" title="具体的验证"></a>具体的验证</h2><p>该部分不是翻译内容，是根据<a href="http://proguard.sourceforge.net/manual/usage.html" target="_blank" rel="external">ProGuard 的使用方法</a>和<a href="http://proguard.sourceforge.net" target="_blank" rel="external">文档首页</a>，对上述三个步骤的具体验证。<br>由于大部分情况下，<code>Android</code>的混淆只需要考虑<code>Obfuse</code>这个步骤，因为很多第三方依赖包的混淆规则会把 <code>shrink</code>和<code>optimize</code>去掉（比如友盟）。所以先验证这一步。<br>下面的验证步骤，涉及三个类，java打包的命令(Java 环境)，<code>proguard.ja</code>r包(混淆器，进行整个混淆过程的jar包)，<code>proguard.pro</code>文件(写入具体混淆的规则)和<code>Intelij</code>(用来查看<code>class</code>文件)等内容。</p>
<h4 id="Obfuse-步骤验证"><a href="#Obfuse-步骤验证" class="headerlink" title="Obfuse 步骤验证"></a>Obfuse 步骤验证</h4><p>这个步骤，如上所说，主要是对类，方法进行名字的修改，也是 Android 混淆中最重要的部分。为了验证这个过程，我做了下面的demo操作</p>
<ul>
<li>首先写了3个类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.dove.home;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.dove.home;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloWorld2</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Hello World2"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.dove.home;    </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HelloWorld helloWorld = <span class="keyword">new</span> HelloWorld();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>然后编译,打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">javac com/dove/home/Main.java</div><div class="line">javac com/dove/home/HelloWorld2.java</div><div class="line">javac com/dove/home/HelloWorld.java</div><div class="line">//注意在进行下面步骤的时候，我把 com/dove/home 下的 java源码删了</div><div class="line">jar -cvf main_source.jar com</div></pre></td></tr></table></figure>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/18-39-05.jpg" alt=""></p>
<ul>
<li>然后使用混淆器，混淆器其具体使用方法，主要是调用<code>proguard.jar</code>包，然后配置 <code>proguard.pro</code>文件进行具体的参数设置。</li>
</ul>
<p>下面是我<code>proguard.pro</code>文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 源码文件</div><div class="line">-injars main_source.jar</div><div class="line"># 混淆后输出文件</div><div class="line">-outjars main_source_out.jar</div><div class="line"># java 核心 jar 不能混淆</div><div class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</div><div class="line"># 全部不混淆，即三个class文件都会保持原样</div><div class="line">-keep class com.dove.home.Main&#123;*;&#125;</div><div class="line">-keep class com.dove.home.HelloWorld&#123;*;&#125;</div><div class="line">-keep class com.dove.home.HelloWorld2&#123;*;&#125;</div></pre></td></tr></table></figure>
<p>具体的混淆命令，同时参考下图(该步骤会生成混淆后的jar包)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar proguard.jar @proguard.pro</div></pre></td></tr></table></figure>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/17-45-40.jpg" alt=""></p>
<p>注意：然后修改 proguard.pro 文件，内容如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-injars main_source.jar</div><div class="line"># 注意输出包的名字改了</div><div class="line">-outjars main_source_proguard_out.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</div><div class="line">-keep class com.dove.home.Main&#123;*;&#125;</div><div class="line"># 删除了HelloWorld的 keep</div><div class="line">-keep class com.dove.home.HelloWorld2&#123;*;&#125;</div></pre></td></tr></table></figure>
<p>同样运行上面的混淆命令，生成另一个混淆后的包</p>
<p>最后对三个包进行对比，通过代码逆向，进行验证，最快的方式是把生成的 jar 包，当做第三方依赖包直接导入Intellij 中(有decode的功能)，如下图，三个包的区别</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/18-48-53.jpg" alt=""></p>
<p>最初是的源码包和保留<code>HelloWorld</code>,<code>HelloWorld2</code>以及<code>Main</code>入口点的包是一样的，不同的是最后没有保留<code>HelloWorld</code>入口点的包，它的<code>HelloWorld</code>变成了<code>a</code>，而<code>Main</code>和<code>HelloWorld2</code>都正常没有被修改</p>
<h4 id="Optimize-步骤验证"><a href="#Optimize-步骤验证" class="headerlink" title="Optimize 步骤验证"></a>Optimize 步骤验证</h4><p>同样，修改 proguard.pro 文件，内容如下，然后运行混淆命令，生成新的 jar 包</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-injars main_source.jar</div><div class="line"># 输出包名改了，方便对比</div><div class="line">-outjars main_source_proguard_not_optimize_out.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</div><div class="line"># 加上不进行优化的限制</div><div class="line">-dontoptimize</div><div class="line">-keep class com.dove.home.Main&#123;*;&#125;</div><div class="line">-keep class com.dove.home.HelloWorld2&#123;*;&#125;</div></pre></td></tr></table></figure>
<p>同上，导入IntelliJ，对比上一步中混淆后的 jar 包，发现名字没啥变化，但内容不一样了<br><img src="http://ob9rvakdw.bkt.clouddn.com/18-51-28.jpg" alt=""><br>首先是没有添加 <code>-dontoptimize</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.dove.home;</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是添加了 <code>-dontoptimize</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.dove.home;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上述译文中所说，optimize 会进行代码优化，不是入口点的代码，会变成<code>final</code>，<code>private</code>等等，该步骤验证完毕。</p>
<h4 id="Shrink-步骤验证"><a href="#Shrink-步骤验证" class="headerlink" title="Shrink 步骤验证"></a>Shrink 步骤验证</h4><p>修改 proguard.pro 文件，进行压缩，同时不对 HelloWorld，HelloWorld2进行入口点的保留</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-injars main_source.jar</div><div class="line">-outjars main_source_proguard_shrink_out.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</div><div class="line"></div><div class="line">-keep class com.dove.home.Main&#123;*;&#125;</div><div class="line"># 注意对比之前，删除了HelloWorld和HelloWorld2的 keep</div></pre></td></tr></table></figure>
<p>修改 proguard.pro 文件，不进行压缩，同样不对 HelloWorld，HelloWorld2进行入口点的保留</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-injars main_source.jar</div><div class="line">-outjars main_source_proguard_not_shrink_out.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</div><div class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</div><div class="line"># 添加不进行压缩</div><div class="line">-dontshrink</div><div class="line">-keep class com.dove.home.Main&#123;*;&#125;</div></pre></td></tr></table></figure>
<p>其结果对比<br>添加了 <code>-dontshrink</code>标志<br><img src="http://ob9rvakdw.bkt.clouddn.com/18-58-04.jpg" alt=""><br>未添加 <code>-dontshrink</code>标志<br><img src="http://ob9rvakdw.bkt.clouddn.com/18-58-16.jpg" alt=""><br>此处消失的<code>b</code>其实就是<code>HelloWorld2</code>，而留下的<code>a</code>则是<code>HelloWorld</code>,原因很简单，因为Main里面持有了<code>HelloWorld</code>的引用，而<code>HelloWorld2</code>则从未被用到，所以就被抛弃了。<br>由此验证，shrink阶段，Proguard(混淆器)会把无用类文件等删除，一些被动态获取的类就需要注意了，需要进行<code>-keep</code>操作，使其成为入口点。</p>
<hr>
<p>以上就是对混淆整个过程的验证</p>
<p>对于 Android 混淆，一些需要注意的东西，会在下一篇文章中记录</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/19/旧-Android-代码混淆-二/" class="prev">PREV</a><a href="/2016/11/18/dagger2-学习-二/" class="next">NEXT</a></div><div data-thread-key="2016/11/19/旧-Android-代码混淆-一/" data-title="[旧]Android 代码混淆(一)" data-url="http://dove.im/2016/11/19/旧-Android-代码混淆-一/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"baiyanwu"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://dove.im">flyer</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>