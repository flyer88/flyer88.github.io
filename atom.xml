<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyer88.github.io</id>
    <title>键盘敲击者</title>
    <updated>2020-06-15T08:26:47.758Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyer88.github.io"/>
    <link rel="self" href="https://flyer88.github.io/atom.xml"/>
    <subtitle>爪哇岛上程序猿 十指弯弯不弄弦 
斗室方屏十余寸 不知今夕是何年</subtitle>
    <logo>https://flyer88.github.io/images/avatar.png</logo>
    <icon>https://flyer88.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 键盘敲击者</rights>
    <entry>
        <title type="html"><![CDATA[算法基础⑤（树的遍历）]]></title>
        <id>https://flyer88.github.io/post/suan-fa-ji-chu-shu-de-bian-li/</id>
        <link href="https://flyer88.github.io/post/suan-fa-ji-chu-shu-de-bian-li/">
        </link>
        <updated>2020-06-15T08:25:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="0x0001树的遍历-简介">0x0001.树的遍历 简介</h3>
<blockquote>
<ol>
<li>
<p>深度遍历的运行过程是先进后出(<code>FILO</code>)的，用的是栈和递归</p>
<p>树的前序，中序，后序遍历</p>
</li>
<li>
<p>广度遍历的运行过程是先进先出(<code>FIFO</code>)的，用的是队列</p>
<p>树的层序遍历</p>
</li>
</ol>
<blockquote>
<p>补充：顺序（根据根）：根左右，中序左根右，后序左右根</p>
<p>​			  层序：按层级输出</p>
</blockquote>
</blockquote>
<p>###0x0002. 树的遍历</p>
<p><strong>递归和栈</strong> （树的前序，中序，后序遍历）</p>
<ol>
<li>
<p>递归实现</p>
<pre><code class="language-java">public class BST {
  ...
	public static void preOrder(TreeNode treeNode){
        if (treeNode == null) return;
        System.out.print(treeNode.data + &quot; &quot;);
        preOrder(treeNode.left);
        preOrder(treeNode.right);
    }

    public static void inOrder(TreeNode treeNode){
        if (treeNode == null) return;
        inOrder(treeNode.left);
        System.out.print(treeNode.data + &quot; &quot;);
        inOrder(treeNode.right);
    }

    public static void postOrder(TreeNode treeNode){
        if (treeNode == null) return;
        postOrder(treeNode.left);
        postOrder(treeNode.right);
        System.out.print(treeNode.data + &quot; &quot;);
    }
}
</code></pre>
</li>
<li>
<p>栈实现</p>
<pre><code class="language-java">public class BST {
  	...
    public static void stackPreOrder(TreeNode treeNode) {
        if (treeNode == null ) return;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
        stack.push(treeNode);
        TreeNode curNode = stack.pop();
        while (!stack.empty() || curNode != null){
            if (curNode != null) {
                System.out.print(curNode.data + &quot; &quot;);
                stack.push(curNode);
                curNode = curNode.left;
            } else {
                curNode = stack.pop();
                curNode = curNode.right;
            }
        }
    }
  
  public static void stackInOrder(TreeNode treeNode) {
        if (treeNode == null ) return;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
        TreeNode curNode = treeNode;
        while (!stack.empty() || curNode != null){
            if (curNode!= null){
              	// 入栈
                stack.push(curNode);
                curNode = curNode.left;
            } else {
               // 回溯
                curNode = stack.pop();
                System.out.print(curNode.data + &quot; &quot;);
                curNode = curNode.right;
            }
           
        }
    }
  
  public static void stackPostOrder(TreeNode treeNode) {
        if (treeNode == null ) return;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
        TreeNode curNode = treeNode;
        TreeNode last = null;
        while (!stack.empty() || curNode != null){
            if (curNode != null) {
                stack.push(curNode);
                curNode = curNode.left;
            } else {
              	// 用 peek，而非 pop
                TreeNode temp = stack.peek();
                //是否变到右子树
                if (temp.right != null &amp;&amp; temp.right != last) {
                    curNode = temp.right;
                } else {
                    System.out.print(temp.data + &quot; &quot;);
                    last = temp;
                    stack.pop();
                }
            }
        }
    }
}
</code></pre>
</li>
</ol>
<p><strong>队列</strong>（树的层序遍历）</p>
<ol>
<li>
<p>具体实现</p>
<pre><code class="language-java">public class BST {
  	...	
		public static void levelOrder(TreeNode treeNode) {
        if (treeNode == null) return;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        queue.offer(treeNode);
        while(!queue.isEmpty()){
            TreeNode cur = queue.poll();
          	// 打印当前节点
            System.out.print(&quot; &quot; + cur.data);
	          // 按顺序入队列即可
            if(cur.left != null) queue.offer(cur.left);
            if(cur.right != null) queue.offer(cur.right);
        }
    }
}
</code></pre>
</li>
</ol>
<p><strong>树打印</strong></p>
<pre><code class="language-java">//输入：			3,2,9,null,null,10,null,null,8,null,4
//输出： 		///////////////////////
      		  //         3         //
      		  //       /  \        //
      		  //      2     8      //
      		  //     / \     \     //
      		  //    9   10    4    //
      		  /////////////////////// 
        
public class BST {

  public static class TreeNode{
    int data;
    TreeNode left;
    TreeNode right;
    public TreeNode(int data){
      this.data = data;
    }
  }
  
  public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inpuList){
    TreeNode treeNode = null;
    if (inpuList == null || inpuList.isEmpty())  {
      return null;
    }
    Integer data = inpuList.removeFirst();
    if (data != null) {
      treeNode = new TreeNode(data);
      treeNode.left = createBinaryTree(inpuList);
      treeNode.right = createBinaryTree(inpuList);
    }
    return treeNode;
  }
  
  public static void main(String[] args) {
        
        ///////////////////////
        //         3         //
        //       /  \        //
        //      2     8      //
        //     / \     \     //
        //    9   10    4    //
        /////////////////////// 
        
        LinkedList&lt;Integer&gt; inpuList = new LinkedList&lt;Integer&gt;(Arrays.asList(new Integer[]{
                3,2,9,null,null,10,null,null,8,null,4
        }));
        TreeNode node = createBinaryTree(inpuList);
  }
  
}
        
        
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法基础④（树的概念和存储）]]></title>
        <id>https://flyer88.github.io/post/suan-fa-ji-chu-si-shu-de-gai-nian-he-cun-chu/</id>
        <link href="https://flyer88.github.io/post/suan-fa-ji-chu-si-shu-de-gai-nian-he-cun-chu/">
        </link>
        <updated>2020-06-15T08:24:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="ox0001-基本概念">OX0001 基本概念</h3>
<ol>
<li>
<p>树</p>
<blockquote>
<p>n(n &gt;= 0) 个节点 的有限集。当 n=0 时，称为空树，在任意一个非空树种有如下特点：</p>
<ol>
<li>有且仅有一个特定的称为根的节点。</li>
<li>当 n &gt; 1 时，其余节点分为 m (m &gt; 0) 个互不相交的有限集，每个集合本身又是一个树，并称为根的子树</li>
</ol>
</blockquote>
</li>
<li>
<p>二叉树</p>
<blockquote>
<p>每个节点只有两个孩子的树</p>
</blockquote>
</li>
<li>
<p>满二插树</p>
<blockquote>
<p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有的叶子节点都在同一个层级</p>
</blockquote>
</li>
<li>
<p>完全二叉树</p>
<blockquote>
<p>对一个有 n 个节点的二叉树，按层级顺序编号，所有节点的编号为 1到 n，如果这个数的所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树</p>
</blockquote>
</li>
</ol>
<h3 id="ox0002-存储方式">OX0002. 存储方式</h3>
<ol>
<li>
<p><strong>链表</strong></p>
<blockquote>
<pre><code class="language-shell">					  [NodeA|data1|left|right]
						//										\\
					//											 \\
				//													\\
[NodeB|data2|null|null]			[NodeC|data3|null|null]
</code></pre>
</blockquote>
</li>
<li>
<p><strong>数组 - 层序存储 (主要用于完全二叉树，否则会大量浪费空间)</strong></p>
<blockquote>
<p>父节点下标为parent，则做孩子的下标为 2* parent + 1，有孩子为 2*parent + 2</p>
<pre><code class="language-shell">				 【1】
				//	 \\
			【2】	  【3】
			//	\\    \\
		【4】 【5】  【6】
			\\
			【8】
			
[1][2][3][4][5][null][6][null][8]
 0  1  2  3  4   5    6   7    8

</code></pre>
</blockquote>
</li>
</ol>
<h3 id="ox0003-bst-二叉查找树二叉排序树">OX0003. <code>BST</code> 二叉查找树/二叉排序树</h3>
<ol>
<li>左子树不为空，左子树的值均小于根</li>
<li>右子树不为空，右子树的值均大于根</li>
<li>左右子树也是 <code>BST</code></li>
<li>时间复杂度: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法基础③（哈希表简介及部分源码分析）]]></title>
        <id>https://flyer88.github.io/post/suan-fa-ji-chu-san-ha-xi-biao-gai-nian/</id>
        <link href="https://flyer88.github.io/post/suan-fa-ji-chu-san-ha-xi-biao-gai-nian/">
        </link>
        <updated>2020-06-15T08:23:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="0x0001-简介">0x0001. 简介</h3>
<ol>
<li>
<p>基本概念</p>
<blockquote>
<ol>
<li>
<p>由两部分组成，数组 + 链表（红黑树，根据链表大小决定是否用）</p>
</li>
<li>
<p>链表实现：查找时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>  -- <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
<p>红黑树实现：查找时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>  -- <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
</li>
<li>
<p>关键难点</p>
<blockquote>
<ol>
<li><code>LoadFactor(负载因子) * Capacity(当前长度) &gt; size</code>  ==&gt; 动态扩容</li>
<li>解决<code>hash</code> 碰撞，链表+红黑树</li>
<li>扰动函数，使得概率分部平均</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="0x0002-put-函数源码解析">0x0002. <code>put</code> 函数源码解析</h3>
<pre><code class="language-java">		public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
      	// 为空处理，直接动态扩容（逻辑较为复杂，单独分析）
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
      	// 数组对应位置内容为空，直接放入
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
          	// 数组的第一个位置
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
            // 红黑树处理
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
              	// 链表处理，无限循环，找到要覆盖的节点 e，break 出局
                for (int binCount = 0; ; ++binCount) {
                   // e 指向下一个节点
                    if ((e = p.next) == null) {
                      	// 尾部插入
                        p.next = newNode(hash, key, value, null);
                      	// 如果链表超过 8 个，转换成红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                  	// 找到对应位置，key 相同，结束循环
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    // 链表迭代指向下一个
                    p = e;
                }
            }
          	// e 不为空，覆盖 e, 返回原值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
              	// 空
                afterNodeAccess(e);
                return oldValue;
            }
        }
        // ？？
        ++modCount;
        //更新size，并判断是否需要扩容。
        if (++size &gt; threshold)
            resize();
      	//空
        afterNodeInsertion(evict);
        return null;
    }


		// hash 计算，扰动函数
 		static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
</code></pre>
<h3 id="0x0003-put时内存状态和运算过程">0x0003. <code>put</code>时内存状态和运算过程</h3>
<p><code>TestHashMap.java</code></p>
<pre><code class="language-java">public class TestHashMap {
    public static void main(String[] args) {
        HashMap&lt;String, Integer&gt; programLanguage = new HashMap&lt;&gt;();
        programLanguage.put(&quot;语文&quot;, 1);
        programLanguage.put(&quot;数学&quot;, 2);
        programLanguage.put(&quot;英语&quot;, 3);
        programLanguage.put(&quot;历史&quot;, 4);
        programLanguage.put(&quot;政治&quot;, 5);
        programLanguage.put(&quot;地理&quot;, 6);
        programLanguage.put(&quot;生物&quot;, 7);
        programLanguage.put(&quot;化学&quot;, 8);

        for (Entry&lt;String, Integer&gt; entry : programLanguage.entrySet()) {
            System.out.println(&quot;key:&quot; + entry.getKey() + &quot; value:&quot;+ entry.getValue());
            System.out.println(&quot;hash code:&quot; + entry.hashCode() +  &quot;\n&quot;);
        }
    }
}
</code></pre>
<p><code>输出结果</code></p>
<pre><code>key:政治 value:5
hash code:831321

key:生物 value:7
hash code:958765

key:历史 value:4
hash code:684328

key:数学 value:2
hash code:828404

key:化学 value:8
hash code:682776

key:语文 value:1
hash code:1136443

key:英语 value:3
hash code:1074975

key:地理 value:6
hash code:721616
</code></pre>
<ol>
<li>
<p>**内存状态 ** (解决哈希碰撞)</p>
<pre><code class="language-shell">&gt;table: HashMap$Node[16]@17
	&gt; 0: HashMap$Node@31 &quot;政治&quot;:&quot;5&quot;
		1: null
		2: null
		3: null
		4: HashMap$Node@32 &quot;生物&quot;:&quot;7&quot;
		5: null
		6: HashMap$Node@33 &quot;历史&quot;:&quot;4&quot;
		7: null
		8: null
		9: null
		10: HashMap$Node@19 &quot;数学&quot;:&quot;2&quot;
		11: HashMap$Node@34 &quot;语文&quot;:&quot;1&quot;
		12: HashMap$Node@35 &quot;英语&quot;:&quot;3&quot;
		13: HashMap$Node@36 &quot;地理&quot;:&quot;6&quot;
		14: null
		15: null
&gt;table[10].next: HashMap$Node@22 &quot;化学&quot;:&quot;8&quot;
 table[10].hash: 828410
</code></pre>
</li>
<li>
<p><strong>扰动函数计算过程</strong></p>
<blockquote>
<p>让高位和低位同时影响最终的 hashCode， <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></p>
<pre><code class="language-shell">key.hashCode() = 682768(化学)
hashCode = 682768 ^ (682768 &gt;&gt;&gt; 16) = 682778
	
二进制状态下转换过程

682768 = 1010 0110 1011 0001 0000

补齐 0 后 ==&gt;

0000 0000 0000 1010 0110 1011 0001 0000
 &gt;&gt;&gt; 16 （高位移至低位）
=	0000 0000 0000 0000 0000 0000 0000 1010


0000 0000 0000 1010 0110 1011 0001 0000 
^ （高低位作异或运算）
0000 0000 0000 0000 0000 0000 0000 1010

= 0000 0000 0000 1010 0110 1011 0001 1010

补充:异或运算取决于两个值，与和或运算只取决于单个值
</code></pre>
<blockquote>
<p>补充：</p>
<p><a href="https://www.javacodegeeks.com/2015/09/an-introduction-to-optimising-a-hashing-strategy.html">关于位移jdk1.7 和 1.8 中单次和多次的区别</a></p>
<p>[知乎的简单解释](JDK 源码中 HashMap 的 hash 方法原理是什么？ - 胖君的回答 - 知乎 https://www.zhihu.com/question/20733617/answer/111577937)</p>
</blockquote>
</blockquote>
</li>
<li>
<p><strong>取模</strong></p>
<blockquote>
<p>获取在数组中的位置: <code>tab[i = (n - 1) &amp; hash]</code> ==&gt;  <code>tab[10]</code></p>
<p>n 是 HashMap 的长度，2^m ， 上述情景中 m = 4，n 为 16（数组长度），n = 0B10000</p>
<p>计算过程如下：</p>
<pre><code class="language-shell">	      0000 0000 0000 0000 0000 0000 0001 0000     - 1
=&gt;		  0000 0000 0000 0000 0000 0000 0000 1111 		= 15
	 &amp;    0000 0000 0000 1010 0110 1011 0001 1010    （682778，扰动函数得到的 hashCode)
=&gt; 	    0000 0000 0000 0000 0000 0000 0000 1100 		= 10
</code></pre>
</blockquote>
</li>
<li>
<p>数组中已经有值，插入链表末端：<code>p.next = newNode(hash, key, value, null);</code></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法基础② （栈和队列基础）]]></title>
        <id>https://flyer88.github.io/post/suan-fa-ji-chu-er-zhan-he-dui-lie-ji-chu/</id>
        <link href="https://flyer88.github.io/post/suan-fa-ji-chu-er-zhan-he-dui-lie-ji-chu/">
        </link>
        <updated>2020-06-15T08:21:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<ol>
<li>
<p>物理结构和逻辑结构区别</p>
<blockquote>
<table>
<thead>
<tr>
<th></th>
<th>线性结构</th>
<th>非线性结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑结构</td>
<td>表，队列，栈</td>
<td>树，图</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>顺序存储结构</th>
<th>链式存储结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理结构</td>
<td>数组</td>
<td>链表</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li>
<p>栈（FILO）</p>
<p>先进后出，导航条，递归调用</p>
</li>
<li>
<p>队列 （FIFO）</p>
<p>Android main Looper 消息队列，爬虫队列</p>
</li>
</ol>
<h3 id="基本实现">基本实现</h3>
<ol>
<li>
<p>栈</p>
<pre><code class="language-java">// 双向链表实现
public class Stack&lt;T&gt;{
  int height;
  Node&lt;T&gt; head,tail;
  
  public void push(T item){
    Node&lt;T&gt; tempNode = new Node&lt;T&gt;(item);
    if (height == 0) {
      head = tempNode;
      tail = head;
    } else {
	    tail.next = tempNode;
      tail = tempNode;
    }  
    height = height + 1;
  }
  
  public T pop(){
    if (height == 0) {
			return null;
    } else if (height == 1){
      result = head;
    	tail = null;
      head = null;
      height = 0;
      return result;
    } else {
			tail = tail.pre;
      result = tail.next;
      tail.next = null;
      height = height - 1;
	    return result;
    }
  }
  
  public T peek(){
    
  }
}
</code></pre>
</li>
<li>
<p>队列</p>
<pre><code class="language-java">// 数组实现
public class Queue&lt;T&gt;{
  
  int size;
  Object[] queue;
  final static capacity = 10;
  
  public Queue() {
    queue = new Object[capacity];
    size = capacity;
  }
  
  public void enqueue(T t){
    if (size &gt;= queue.length) {
      // 动态扩容
      int[] newArray = new int[2 * capacity]{};
	    System.copyArray(queue,newArray);
  	  queue = newArray;
	    size = queue.length;
    }
		queue[size] = t;
  }

  public T poll(){
    if (size == 0) {
      throw new Exception(&quot;队列为空&quot;);
    }
		T t = queue[size -1];
   	queue[size-1] = null;
    return t;
  }

  public T peek(){
    if (size == 0) {
      throw new Exception(&quot;队列为空&quot;);
    }
		return queue[size - 1];
  }
}
</code></pre>
</li>
</ol>
<h1 id="2">2.</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法基础① （基础概念、数组和链表基础）]]></title>
        <id>https://flyer88.github.io/post/suan-fa-ji-chu-yi/</id>
        <link href="https://flyer88.github.io/post/suan-fa-ji-chu-yi/">
        </link>
        <updated>2020-06-15T08:18:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-基础概念">1. 基础概念</h1>
<ol>
<li>
<p>算法类型</p>
<ul>
<li>计算</li>
<li>查找</li>
<li>排序</li>
<li>最优决策</li>
</ul>
</li>
<li>
<p>数据结构</p>
<ul>
<li>
<p>线性结构</p>
<blockquote>
<p>数组，链表，栈，队列，哈希表</p>
</blockquote>
</li>
<li>
<p>树</p>
<blockquote>
<p>二叉树，多插树</p>
</blockquote>
</li>
<li>
<p>图</p>
<blockquote>
<p>有向图，无向图，环</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>复杂度</p>
<ul>
<li>
<p>时间复杂度</p>
<blockquote>
<ol>
<li>运行时间是常数量级，则用常数 1 表示</li>
<li>只保留时间函数中的最高阶项</li>
<li>如果最高阶项存在，省去最高阶项的系数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 是算法所消耗的时间函数</p>
<p>$T(n) = 2 $  =&gt;  $ O(1)$</p>
<p>$ T(n) =  5logn $   =&gt;   $ O(logn)$</p>
<p>$ T(n) = 3n $   =&gt;   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>$T(n) =  0.5n^2 + 0.5n  $   =&gt;  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>$ O(1)&lt;O(logn)&lt; O(n)&lt;O(n^2) $</p>
<p>其他:  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>  $O(2^n) $ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
</li>
<li>
<p>空间复杂度</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">S(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>是算法所消耗的存储空间函数</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h1 id="2-数组和链表基础">2. 数组和链表基础</h1>
<h3 id="数组">数组</h3>
<ol>
<li>
<p>物理连续</p>
</li>
<li>
<p>基本操作</p>
<ul>
<li>
<p>查询更新</p>
<pre><code class="language-java">int[] array = new int[]{1,2,3,4};
System.out.println(array[1]);// 查
array[0] = 0;// 改
</code></pre>
</li>
<li>
<p>删除</p>
<pre><code class="language-java">int[] array = new int[]{1,2,3,4};

int deletePosition = 2;
if(deletePosition &gt;= array.length){
	throw new Exception(&quot;删除数字超过数组长度！&quot;);
}
for(int i = deletePosition;i&lt;array.size-1;i++){
	array[i]  = array[i+1];
}

</code></pre>
</li>
<li>
<p>增加</p>
<pre><code class="language-java">int s = 3;
final static int capacity = 5
int[] array;
int size;

public MyArray(){
	array = new Array[capacity];
  size = array.length;
}


public void insert(int index,int value) {
  if (index &gt;= size) {
    int[] newArray = new int[2 * capacity]{};
    System.copyArray(array,newArray);
    array = newArray;
    size = array.length;
    insert(index,value);// 递归调用，可以自动扩容多次
  } else {
    for(int i = size-1;i&gt;index:i--){
      array[i] = array[i-1];
    }
    array[index] = value;
  }
}

// array = new Array{1,2,3,4,5}
// insert(2,20)
  [1,2,3,4,5] 
	-&gt; [1,2,3,4,5,null,null,null,null,null]
  -&gt; [1,2,3,4,5,5,null,null,null,null]
  -&gt; [1,2,3,4,4,5,null,null,null,null]
  -&gt; [1,2,3,3,4,5,null,null,null,null]
  -&gt; [1,2,2,3,4,5,null,null,null,null]
  -&gt;
  -&gt; [1,2,20,3,4,5,null,null,null,null]
  
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="链表">链表</h3>
<ol>
<li>
<p>非物理连续，逻辑连续</p>
</li>
<li>
<p>基本操作</p>
<ul>
<li>
<p>查找/更新</p>
<pre><code class="language-java">int targetIndex = 10;
int targetValue = 233;
int i = 0;
Node curNode;
// 查找
while(!curNode.next
     	&amp;&amp; i &lt; targetIndex) {
  curNode = curNode.next
	i = i + 1;
}
// 更新
curNode.value = targetValue;
</code></pre>
</li>
<li>
<p>增加/删除</p>
<pre><code class="language-java">int targetIndex = 10;
int size = 20;
Node insertNode;
Node head,tail;


// 增加
if (size == 0) {
  head = insertNode;
  tail = insertNode;
  size = size + 1;
} else if (targetIndex  == 0) {
  insertNode.next = head;
  head = insertNode;
  size = size + 1;
} else if (targetIndex == size) {
  tail.next = insetNode;
	tail = insertNode;
  size = size + 1;
} else if (targetIndex &gt; 0 &amp;&amp; targetIndex &lt; size ){
  Node preNode = get(targetIndex -1);
  Node nextNode = preNode.next;
  preNode.next =  insertNode;
  insertNode.next = nextNode;
  size = size + 1;
} else {
  throw new Exception(&quot;超过链表长度&quot;);  
}

// 删除

if (size == 0) {
  throw new Exception(&quot;链表为空&quot;);
} else if (targetIndex  == 0) {
  Node newHead = head;
  head = head.next;
  newHead.next = null;
  size = size - 1;
} else if (targetIndex == size) {
  tail = get(size -1);
  tail.next = null;
  size = size - 1;
} else if (targetIndex &gt; 0 &amp;&amp; targetIndex &lt; size ){
  Node preNode = get(targetIndex -1);
  Node curNode = preNode.next;
  preNode.next = curNode.next;
  curNode.next = null;
  size = size - 1;
} else {
  throw new Exception(&quot;超过链表长度&quot;);  
}


</code></pre>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[repo 管理 git 仓库]]></title>
        <id>https://flyer88.github.io/post/repo-guan-li-git-cang-ku/</id>
        <link href="https://flyer88.github.io/post/repo-guan-li-git-cang-ku/">
        </link>
        <updated>2020-06-11T04:25:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-同类技术方案对比">1. 同类技术方案对比</h2>
<ol>
<li><code>git submodule</code>/<code>git subtree</code>，都是把代码当做一个单一的大仓库，进行管理处理</li>
<li><code>repo</code>，是把所有的代码当做一个工程处理，各个模块可以是独立的仓库，而 <code>repo</code> 只是一个执行 <code>git</code> 命令的脚本，方便组织各个 <code>git</code> 仓库，<code>repo</code> 的最佳实践就是 <code>AOSP</code> 源码的管理</li>
</ol>
<blockquote>
<p>注： 此处只对比了 <code>submodule</code> 和 <code>repo</code> 部分内容，<code>subtree</code> 和 <code>submodule</code> 差不多，核心区别是一个是引用仓库，一个是导入仓库，会增大 <code>.git</code> 文件容量</p>
</blockquote>
<table>
<thead>
<tr>
<th>核心部分对比</th>
<th>git submodule</th>
<th>Repo</th>
</tr>
</thead>
<tbody>
<tr>
<td>管理方式</td>
<td>查看 <code>.gitmodules</code> 文件可以看到所有 <code>submodule</code> 介绍，知己用，无须维护</td>
<td><code>manifest</code> 文件管理，需要根据分支维护</td>
</tr>
<tr>
<td>更新方式</td>
<td>子仓库更新，父级也要更新，容易出现坑</td>
<td>各个仓库独立更，无坑</td>
</tr>
<tr>
<td>命令工具方面</td>
<td><code>git</code> 的展示效果</td>
<td>更多批量效果，具体可以看本文后续的几个命令介绍</td>
</tr>
</tbody>
</table>
<h2 id="2-repo-的使用">2. Repo 的使用</h2>
<h3 id="repo-配置">repo 配置</h3>
<ol>
<li>下载 <code>repo</code> 脚本<pre><code class="language-shell">brew install repo	
</code></pre>
</li>
<li>修改镜像地址，避免墙的问题， <code>.zshrc</code> 或者 <code>.bashrc</code> 加入<pre><code class="language-shell">export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'
</code></pre>
</li>
</ol>
<h3 id="项目中使用">项目中使用</h3>
<ol>
<li>
<p>初始化设置 <code>manifest</code> 文件</p>
<ul>
<li>
<p>放置位置</p>
<blockquote>
<ol>
<li>主项目 <code>git</code> 仓库中</li>
<li>另开一个<code>git</code> 仓库</li>
</ol>
<p>项目 <code>git</code> 仓库数量不大，频繁新增修改切出分支时，<code>manifest</code> 独立仓库不具有优势，</p>
<p>嵌入主仓库有明显的优势，在 <code>develop</code> 中，改动 <code>mainifest</code> 文件，快速切出对应的工作分支</p>
</blockquote>
</li>
<li>
<p>文件内容</p>
<blockquote>
<p><a href="https://gerrit.googlesource.com/git-repo/+/master/docs/manifest-format.md"><strong><code>repo manifest</code> 参数文档</strong></a></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;manifest&gt;
  &lt;!-- remote 指定远程分支，name 是远程分支的名字，fetch 拉去地址的 host，sync-j 是指同步拉去线程数量 --&gt;
    &lt;remote name=&quot;taofen8&quot; fetch=&quot;http://gitlab.taofen8.com/&quot;  sync-j=&quot;1&quot;/&gt;
	&lt;!-- default 是配置默认的参数，默认情况下，拉去 master，用远程名字叫 taofen8 的地址--&gt;  
    &lt;default revision=&quot;master&quot; remote=&quot;taofen8&quot;/&gt;
  &lt;!-- 此处配置项目仓库地址，name 是指在 remote 的 host 之后，补充上对应的名字即可，path 是指本地的配置路径地址--&gt;
  &lt;!-- 注意，第一个 project 没有指定 remote，就会使用 default 中的配置参数了--&gt;
    &lt;project name=&quot;taofen8_app/b_taofen8_flutter&quot; path=&quot;b_taofen8_flutter&quot;/&gt;
    &lt;project name=&quot;taofen8_app/b-taofen8_phone-iOS&quot; remote=&quot;taofen8&quot; path=&quot;b-taofen8_phone-iOS&quot;/&gt;
&lt;/manifest&gt;
</code></pre>
</blockquote>
</li>
</ul>
</li>
<li>
<p>拉取同步仓库</p>
<pre><code class="language-shell"># 该步骤指，拉取 manifest 文件，
# -u 指定 manifest 文件所在的仓库地址，-b 指定 manifest 仓库的分支
# 如果要拉取 develop 的分支，就 -b develop 就可以
# 此处把 manifest 文件放置在 flutter 主项目中
➜ repo init -u http://gitlab.taofen8.com/taofen8_app/b_taofen8_flutter -b master
# 该步骤指，根据 manifest 文件进行 git pull 对应分支，放置到对应位置
➜ repo sync
</code></pre>
</li>
<li>
<p>切出分支</p>
<pre><code class="language-shell"># 根据 manifest 文件 revision 中指定的分支，切出分支，进行开发
# 当前栗子中，feature/flutter 的 head 和 master head 是相同的
# 因为 manifest 中 default 的 revision 值是 master
➜ repo start feature/flutter --all
# 查看当前仓库的分支
➜ repo branch
*  feature/flutter              | in all projects
</code></pre>
</li>
<li>
<p>几个特别命令介绍</p>
<pre><code class="language-shell"># 查看各个仓库的状态
➜ repo status
project b-taofen8_phone-iOS/                    branch feature/flutter
project b_taofen8_flutter/                      branch feature/flutter

# 当有改动以后
➜ repo status
project b-taofen8_phone-iOS/                    branch feature/flutter
 -m     README.md
project b_taofen8_flutter/                      branch feature/flutter

# 所有的仓库执行同一个命令
# repo forall -c &quot;git push&quot; 等等
➜ repo forall -c &quot;pwd&quot;
/Users/dove/Documents/code/work/taofen8/b-taofen8_phone-iOS
/Users/dove/Documents/code/work/taofen8/b_taofen8_flutter
</code></pre>
</li>
<li>
<p><code>local manifest</code> 使用<br>
有时候会出现本地临时新增一些仓库进去，或者移除部分仓库，但又不需要更新到 <code>manifest</code> 中，这个时候 <code>local manifest</code>  就有作用了。<br>
在对应目录新增  <code>.repo/local_manifests/default.xml</code></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;manifest&gt;
    &lt;project name=&quot;taofen8_app/b-taofen8-Android&quot; remote=&quot;taofen8&quot; path=&quot;b-taofen8-Android&quot;/&gt;
&lt;/manifest&gt;
</code></pre>
<p>执行 <code>repo sync</code>， 执行会拉取新增的项目</p>
<pre><code class="language-shell">➜ repo sync
warning: redirecting to http://gitlab.taofen8.com/taofen8_app/b_taofen8_flutter.git/
Fetching project taofen8_app/b_taofen8_flutter
warning: redirecting to http://gitlab.taofen8.com/taofen8_app/b_taofen8_flutter.git/
Fetching projects:  50% (1/2)
Fetching project taofen8_app/b-taofen8-Android
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
curl: (22) The requested URL returned error: 401 Unauthorized
Server does not provide clone.bundle; ignoring.
warning: redirecting to http://gitlab.taofen8.com/taofen8_app/b-taofen8-Android.git/
....
....
</code></pre>
<blockquote>
<p>此处简单解释下原理，<code>repo</code> 会合并 <code>default.xml</code> 和 <code>local_manifest/default.xml</code></p>
<p>再去拉取合并后的 <code>manifest</code> 的内容，具体可以 <a href="https://duanqz.github.io/2016-04-15-Android-Local-Manifests-Practice"><strong>参考该文章</strong></a></p>
</blockquote>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人简历]]></title>
        <id>https://flyer88.github.io/post/ge-ren-jian-li/</id>
        <link href="https://flyer88.github.io/post/ge-ren-jian-li/">
        </link>
        <updated>2020-06-11T03:51:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>🚧🚧本简历分为以下五部分：<br>
【个人基本信息】【技能点】【工作经历】<br>
【主要项目介绍】【自我描述】</p>
</blockquote>
<h2 id="个人基本信息">个人基本信息</h2>
<p><strong>姓名:</strong> 许鹏飞  					<strong>性别:</strong> 男					<strong>年龄:</strong> 26</p>
<p><strong>学校及专业</strong>: 杭州电子科技大学 软件工程学院 本科</p>
<p><strong>工作年限:</strong>  4年 				<strong>邮箱:</strong> flyer88xu@gmail.com</p>
<p><strong>GitHub:</strong> <a href="https://github.com/flyer88">https://github.com/flyer88</a> 		<strong>个人博客:</strong> <a href="http://flyer88.github.io">http://flyer88.github.io</a></p>
<p><strong>期望职位:</strong> <code>Android</code> 开发工程师 		<strong>期望薪资:</strong>  25k+ 		<strong>期望工作地:</strong> 杭州</p>
<hr>
<h2 id="技能点">技能点</h2>
<h4 id="1-android-技能点">1. <code>Android</code> 技能点</h4>
<ul>
<li>熟练掌握 <code>Android</code> 基础，包括四大组件的，常见布局的使用，了解 <code>inflate</code> 过程的源码（借用其中的 <code>LayoutFactory</code> 实现过一个开源库，用来批量替换控件）。</li>
<li><code>View</code> 层，了解 <code>View</code> 层源码，能实现常见自定 <code>View</code>，能使用<code>ListView</code>,  <code>RecycleView</code>, <code>ViewPager</code> 等常见控件，了解  <code>RecyclerView</code> 原理。</li>
<li>了解 <code>webview</code>，有 <code>Vue</code> 开发经验，能进行 <code>Hybird</code> 开发，写过 <code>JSBridge</code> 的库，实现 <code>Java</code> 和 <code>JavaScript</code> 的异步通信。</li>
<li>熟悉使用 <code>RxJava</code> + <code>OkHttp</code> + <code>Retrofit</code> + <code>Gson</code> 进行开发，阅读过部分 <code>OkHttp</code> 和 <code>Retrofit</code> 源码。</li>
<li>架构上，使用 <code>MVP</code> 和 <code>MVVM</code> 开发。两种架构都熟练掌握，了解原理，偏爱 <code>MVVM</code>，参考 <code>DataBinding</code> ，实现过自己的双向绑定库。</li>
<li>业务架构上，设计过大型 <code>App</code> 的底层架构，并实现 <code>maven</code> 化工作，从而推进上层业务的模块化工作。</li>
</ul>
<h4 id="2-基础技能点">2. 基础技能点</h4>
<ul>
<li>有一定的网络基础，熟悉 <code>http</code> 协议，了解 <code>websocket</code> 等相关协议，了解下层 <code>TCP/IP</code> 协议。</li>
<li>熟练掌握 <code>Android Studio</code> ，了解 <code>gradle</code> 一些常见配置，会用 <code>python</code> 脚本处理一些常见问题，由自动化经验，了解 <code>jekins</code>。</li>
<li>掌握基本的 <code>git</code> 操作，了解并实行过 <code>gitflow</code> 开发流程，配合 <code>repo</code> 工具，管理仓库。</li>
<li>在 <code>Linux/Unix</code> 上，会用基本的命令，对 <code>Unix</code> 类的系统整体结构有所把握。</li>
</ul>
<h4 id="3-额外技能点">3. 额外技能点</h4>
<ul>
<li>后端上，用 <code>node</code> 写过一些简单的后台服务，<code>php</code> 构建过自己的个人博客，<code>会用 docker</code>。</li>
<li>前端上，会简单使用 <code>vue</code> 搭建单页应用。</li>
<li>设计上，会用 <code>sketch</code> ，做过自己小项目的设计稿。</li>
<li>合作上，常见第三方团队合作工具，包括不限于 钉钉, <code>bearchat</code>, <code>tower</code>, <code>github</code>, <code>gitflow</code> <code>jenkins</code> 等。</li>
<li>管理上，有带人经验，管理过 3 人小组，能很好的分配工作，并推进工作。</li>
<li>附加技能，英语 6 级，基本无障碍阅读文档，自带梯子，熟练使用 <code>google</code> 和 <code>StackOverflow</code>。</li>
</ul>
<hr>
<h2 id="工作经历">工作经历</h2>
<h4 id="1杭州尘埃科技有限公司-201504-201606任职-android-开发工程师">1.【杭州尘埃科技有限公司】--  (2015.04-2016.06)任职 <code>Android</code> 开发工程师</h4>
<ul>
<li>【云集】- <code>Android</code> 客户端(2015.04-2016.06）， 一个浏览器应用，简洁，<code>h5</code> 性能高于 <code>Chrome</code> 等浏览器。
<ol>
<li>菜单栏模块，包括页面收藏动画及功能，分享模块实现，网页 刷新前进后退，已打开的网页应用列表显示，回到应用主页功能等等。</li>
<li>整个用户模块，包括用户登陆注册登 录，用户数据同步。设置模块，夜间模式的实现，语言切换功能。</li>
</ol>
</li>
<li>【<code>Link</code>】- <code>Android</code> 客户端(2015.06-2016.06)，一个工具型应用，主要作用是串联一些操作，举例，一键同时发送文字等内容到 <code>QQ</code> 好友，微信朋友圈，微博。 整个 <code>APP</code> 的功能实现，下面是几个重要模块介绍。
<ol>
<li>主界面商店界面实现。</li>
<li>云任务操作模块，具体单个操作的解析以及界面的实现，责任链的使用。</li>
</ol>
</li>
<li>【<code>Pero</code>】- <code>Android</code> 客户端(2016.01-2016.06)， 图片社区应用。
<ol>
<li>首页图片瀑布流的展示处理。</li>
<li>上传模块 的设计与实现。</li>
<li>第三方支付模块(支付宝)的接入，以及界面的实现。</li>
</ol>
</li>
</ul>
<h4 id="2杭州火小二科技有限公司二维火-201607-201902任职-android-开发工程师">2.【杭州火小二科技有限公司（二维火）】--  (2016.07-2019.02)任职 <code>Android</code> 开发工程师</h4>
<p>​	【火掌柜】- Android 客户端，面向B端的餐饮客户端。官网地址为，<a href="http://2dfire.com">http://2dfire.com</a>。</p>
<ul>
<li><strong>主要业务项目</strong>
<ol>
<li>微信营销，对接微信，设计整个业务子模块。</li>
<li>信用贷，对接 <code>web</code> 端，实现通用通信方案，实现 <code>JSBridge</code> 库。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>主要技术项目</strong>
<ol>
<li><code>Celebi</code> -- 针对表单页面的跨平台通用动态化技术解决方案。</li>
<li><code>App</code> 内部统一路由，包裹 <code>ARouter</code> ，用拦截器模式，方便加入业务层需要的通用代码。</li>
<li><code>App</code> 模块化，底层 <code>Maven</code> 化，抽离各个业务层，设计底层依赖结构，同时配合 <code>facade</code> 方式，实现跨模块通信。</li>
</ol>
</li>
</ul>
<h4 id="3杭州淘粉吧网络技术有限公司-201903-至今任职-android-开发工程师">3.【杭州淘粉吧网络技术有限公司】--  (2019.03-至今)任职 <code>Android</code> 开发工程师</h4>
<p>【淘粉吧】- <code>Android</code> 客户端，返利类 <code>App</code>，同时支持一个虚拟穿衣类功能。官网地址:<a href="https://taofen8.com">http://taofen8.com</a></p>
<ul>
<li>【淘粉吧】
<ol>
<li>本地购物车，爬虫调用，倒计时动态刷新列表等基本功能的维护</li>
<li>商城页面改造开发，支付宝提现功能实现，最初版本的实现，已经后期多个优化项目。</li>
<li>抖音等第三方 <code>sdk</code> 接入与对应功能开发</li>
</ol>
</li>
<li>【爱穿搭】<code>App</code> 并入【淘粉吧】
<ol>
<li>业务上： 脸部建模，虚拟形象，身体脸部细节调整等等。</li>
<li>代码层： <code>native</code> 代码的打 <code>so</code> 包，删除无用依赖，抽离虚拟形象核心层等。</li>
<li>新增业务功能，搭配师相关功能开发，接入第三方美颜等等</li>
</ol>
</li>
<li>【海狐海淘】- <code>Android</code> 客户端(2019.03-至今)
<ol>
<li>购物车/结算页功能开发更新等</li>
<li>日常维护</li>
</ol>
</li>
<li>其他技术内容
<ol>
<li><code>target</code> 升级 26，包括 <code>service</code> 兼容，顶部透明栏兼容等等</li>
<li><code>Jenkins</code> 自动打包机器人</li>
<li>爱穿搭优化，图片 <code>OOM</code> 奔溃修复，多图合成流程逻辑优化</li>
<li><code>kotlin</code> 引入，开发</li>
<li>搭建基于<code>sentry</code>的性能统计后台，并接入</li>
</ol>
</li>
</ul>
<hr>
<h2 id="主要项目介绍">主要项目介绍</h2>
<h4 id="1-celebi-跨平台ios-和-android通用动态化技术解决方案">1. <code>Celebi</code> -- 跨平台(<code>iOS</code> 和 <code>Android</code>)通用动态化技术解决方案。</h4>
<ul>
<li><strong>项目介绍</strong>：掌柜 <code>APP</code> 中存在大量类似的表单页面，每次开发都会耗费大量时间，因此，考虑后端下发 <code>JSON</code> 数据，客户端读取数据，动态渲染表单页面，目前已经在 <code>App</code> 中铺了大量页面。</li>
<li><strong>同类方案对比</strong>：项目区别于 <code>ReactNative</code> 和 <code>Weex</code> 相关原理，该方案中所有的控件渲染，都是本地 <code>java</code> 代码执行。<code>JSON</code> 描述中只处理简单逻辑，复杂逻辑均由本地代码实现，针对表单页面具有很强的适用性。</li>
<li><strong>本人工作</strong>：后端，<code>iOS</code> 端，和 <code>Android</code> 端，三端架构推进，<code>Android</code> 端负责人，<code>Android</code> 端技术架构设计并落地具体代码。</li>
<li><strong>技术实现</strong>上:
<ol>
<li>底层解释器实现: 用来解析通用的的一些表达式和函数。
<blockquote>
<p>PS： 个人喜欢捣鼓各种语言，喜欢编译原理，实现过一些简单的解释器</p>
</blockquote>
</li>
<li>运行时变量池实现：页面内变量的缓存池，全局变量和局部变量的实现。</li>
<li>双向绑定等功能的实现：页面交互时，控件上的数据和变量池中变量的双向绑定。</li>
<li>注解方案落地并实现：解耦并剔除模板代码，最初用反射处理过，发现字符串拼接耗时过多，后改为 <code>annotation processor</code>。</li>
</ol>
</li>
<li><strong>项目成果</strong>:
<ol>
<li>单个表单页面，在没有新增控件情况下，熟练情况下，半小时对接完一个页面，同时适配 iOS 和 Android。</li>
<li>在本人离职前，已经介入 5 个项目的开发，涉及 10 多个页面。</li>
</ol>
</li>
</ul>
<h4 id="2-淘粉吧-爱穿搭功能开发">2. 【淘粉吧-爱穿搭】功能开发</h4>
<ul>
<li><strong>项目介绍</strong>:【爱穿搭】 功能是一个虚拟穿衣的业务，该项目主要包括接入该功能，以及后续业务开发。</li>
<li><strong>本人工作</strong>: 由于原有功能代码过于老旧，接近完全重写，同时完成接入核心功能开发
<ol>
<li>原有美颜功能的 <code>native</code> 代码进行打包最新的 <code>so</code> 包</li>
<li>基于 <code>RxJava</code> 设计整套人物部位图片的下载，并且基于坐标，进行合成完整的人物形象的流程</li>
<li>完善建脸部分失败重试逻辑</li>
</ol>
</li>
<li><strong>项目成果</strong>: 人物形象加载速度从原来 2-3秒，提升至 1-2秒</li>
</ul>
<hr>
<h2 id="自我描述">自我描述</h2>
<h4 id="1-经历">1. 经历</h4>
<ul>
<li>本人大三跟随大神创业，写 <code>Android</code> 约一年半，共参加杭州尘埃科技公司三个项目。整个过程中，几乎从零开始自学 <code>Android</code>，在专注 <code>Android</code> 的同时，折腾过一些其他的技术，包括 <code>Linux</code> 服务器的一些知识，<code>Web</code> 前后端的相关知识。</li>
<li>于2016年6月份毕业，同时辞职，7月份入职杭州火小二科技有限公司，于 2019 年 1 月底离职。在职期间，只有一次没有<code>OKRS</code> 7 分。除此之外，技术上打好了 <code>Android</code> 的基础，也推动了组内技术能力的发展，同时个人还了解了其他语言，包括 <code>Scala</code> <code>Python</code> <code>JavaScript</code> 等，并或多或少应用于一些小项目上。</li>
<li>2019 年 3 月，加入淘粉吧，在此期间，主要学习了 <code>kotlin</code>，了解 <code>native</code> 编译。初步了解了 <code>flutter</code>,基于 <code>python</code> 和 <code>jenkins</code> 完成自动化(包括多渠道等)打包，通知钉钉或邮件，同时备份到 <code>NAS</code> 上，推送到蒲公英第三方平台。</li>
</ul>
<h4 id="2-为人">2. 为人</h4>
<ul>
<li>对技术充满热情，喜欢技术驱动的工作氛围，有小小的技术崇拜，热爱推广技术，喜欢分享。</li>
<li>工作负责，学习能力强，方向明确，积极向上，不怕折腾，爱折腾。</li>
<li>与人为善，能积极融入团队，带人积极，三观端正，不用技术作恶。</li>
</ul>
]]></content>
    </entry>
</feed>