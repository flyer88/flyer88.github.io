<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flyer88.github.io</id>
    <title>键盘敲击者</title>
    <updated>2020-06-17T08:00:51.417Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flyer88.github.io"/>
    <link rel="self" href="https://flyer88.github.io/atom.xml"/>
    <subtitle>爪哇岛上程序猿 十指弯弯不弄弦 
斗室方屏十余寸 不知今夕是何年</subtitle>
    <logo>https://flyer88.github.io/images/avatar.png</logo>
    <icon>https://flyer88.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 键盘敲击者</rights>
    <entry>
        <title type="html"><![CDATA[关于 OOM]]></title>
        <id>https://flyer88.github.io/post/guan-yu-oom/</id>
        <link href="https://flyer88.github.io/post/guan-yu-oom/">
        </link>
        <updated>2020-06-17T07:58:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><code>OOM</code> 类型</li>
<li><code>OOM</code> 错误原因</li>
<li><code>OOM</code> 定位问题</li>
</ul>
<h3 id="0x0001-oom-类型">0x0001. <code>OOM</code> 类型</h3>
<ol>
<li>
<p><strong>Java 堆栈溢出，多数原因是内存泄露或者图片过大</strong></p>
<blockquote>
<p><strong>java.lang.OutOfMemoryError<br>
Failed to allocate a 3225612 byte allocation with 1716008 free bytes and 1675KB until OOM</strong></p>
</blockquote>
</li>
<li>
<p><strong>Java 堆栈溢出，此类 bug 最好让 Glide 之类的图片框架进行统一加载图片，同上</strong></p>
<blockquote>
<p><strong>java.lang.OutOfMemoryError<br>
OOM allocating scaled Bitmap with dimensions 1056 x 330</strong></p>
</blockquote>
</li>
<li>
<p><strong>虚拟内存不足或者单个进程中的线程数到达上限（堆中内存充足，却 OOM，前者可能性极小忽略）</strong></p>
<blockquote>
<p><strong>java.lang.OutOfMemoryError<br>
pthread_create (1040KB stack) failed: Try again</strong></p>
</blockquote>
</li>
<li>
<p><strong><code>JNI</code> 报错，进程打开文件数量达上限或虚拟内存不足（堆中内存充足，却 OOM，后者可能性极小忽略）</strong></p>
<blockquote>
<p><strong>java.lang.OutOfMemoryError<br>
Could not allocate JNI Env</strong></p>
</blockquote>
</li>
<li>
<p><strong>因为 OOM 引起的 OOM，解决上述三种问题，基本就不会出现此类 bug</strong></p>
</li>
</ol>
<blockquote>
<p><strong>java.lang.OutOfMemoryError<br>
OutOfMemoryError thrown while trying to throw OutOfMemoryError; no stack trace available</strong></p>
</blockquote>
<h3 id="0x0002-oom-错误原因">0x0002. <code>OOM</code> 错误原因</h3>
<ol>
<li>
<p>情况一，多数情况是解决内存泄露，可以参考<a href="https://flyer88.github.io/post/nei-cun-xie-lu-fen-xi-ding-wei/">内存泄露分析定位</a>，其次是大图处理</p>
<blockquote>
<p>常见图片处理小技巧</p>
<ol>
<li>Recyclerview 快速滑动时，针对9宫格类 App，可以暂停图片加载 <code>Glide.with(this).pauseRequests()</code></li>
<li>各个 <code>View</code> 的 <code>Background</code> 如果是图片，最好也用 <code>Glide</code> 统一载入</li>
<li>图片尽量用 <code>webp</code></li>
</ol>
</blockquote>
</li>
<li>
<p>情况二，只在 <code>Android 9.0</code> 以上报出，核心是图片统一用 <code>glide</code> 类似的框架处理</p>
<blockquote>
<p>上述两种情况，终极原因都是申请的内存大于 <code>Runtime.getRuntime().maxMemory()</code></p>
</blockquote>
</li>
<li>
<p>情况三，源于 <code>linux</code> 的系统对单个进程开启线程数量的限制</p>
<p>可以监控 <code>/proc/[pid]/task</code>，定位具体线程来源，具体分析参考此<a href="https://www.jianshu.com/p/e574f0ffdb42">文章</a></p>
<blockquote>
<p><code>/proc/sys/kernel/threads-max</code></p>
<p><strong>规定了每个进程创建线程数目的上限</strong></p>
</blockquote>
<pre><code class="language-java">/**
* 获取 task 数量
* 用于解决线程数量暴增导致的 OOM
*/
public static int getTaskCount(){
  File taskFile = new File(&quot;/proc/&quot; + Process.myPid() + &quot;/task&quot;);
  File[] files = taskFile.listFiles();
  int length = files.length; 
}
</code></pre>
</li>
<li>
<p>情况四，源于 <code>linux</code> 的系统对单个进程能打开文件数量的限制</p>
<p>可以监控 <code>/proc/[pid]/fd</code> ，定位具体原因，具体分析参考此<a href="https://www.jianshu.com/p/e574f0ffdb42">文章</a></p>
<blockquote>
<p>对比 <code>/proc/pid/limits</code> 内容，获取  <code>Max open files</code></p>
<p><code>Max open files</code><strong>表示每个进程最大打开文件的数目，进程每打开一个文件就会产生一个文件描述符 fd</strong>（监控 <code>/proc/pid/fd</code> 内的文件数即可)</p>
</blockquote>
<pre><code class="language-java">...
/**
* 获取 PD 数量
* 用于解决文件打开数量暴增导致的 OOM
*/
public static int getPDCount(){
  File fdFile = new File(&quot;/proc/&quot; + Process.myPid() + &quot;/fd&quot;);
  File[] files = fdFile.listFiles();
  int length = files.length; 
}

public static final String prefix = &quot;Max open files&quot;;
public static String PID_LIMITS =  &quot;cat /proc/&quot; + Process.myPid() + &quot;/limits&quot;;
/**
* 获取进程文件限制数量
* 用于解决文件打开数量暴增导致的 OOM
*/
public static String getLimitsInfo() throws IOException {
  Runtime runtime = Runtime.getRuntime();
  java.lang.Process proc = runtime.exec(PID_LIMITS);
  BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream()));
  StringBuffer stringBuffer = new StringBuffer();
  String line = null;
  while ((line = in.readLine()) != null) {
       stringBuffer.append(line);
       if (line.startsWith(prefix)) return line;
  }
  return &quot;&quot;;
}
...

</code></pre>
</li>
<li>
<p>情况五，虚拟内存分配失败(<code>mapp</code> 失败)，<a href="https://cloud.tencent.com/developer/article/1071770">参考此文</a></p>
</li>
</ol>
<h3 id="0x0003-oom-定位问题">0x0003. <code>OOM</code> 定位问题</h3>
<ol>
<li>
<p>线下定位，直接进行分析即可</p>
</li>
<li>
<p>线上采集定位，较为麻烦，具体方案可以参考 <a href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html">美团的 <code>Probe</code> 设计方案</a>，考虑到 <code>LeakCanary</code> 用了新的<code>shark</code>解析<code>hprof</code> 文件，可以在美团的方案上进行升级</p>
</li>
</ol>
<h3 id="文章参考">文章参考</h3>
<p><a href="https://www.jianshu.com/p/e574f0ffdb42">不可思议的OOM</a></p>
<p><a href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html">Probe：Android线上OOM问题定位组件</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1071770">Android 创建线程源码与OOM分析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内存泄露分析定位]]></title>
        <id>https://flyer88.github.io/post/nei-cun-xie-lu-fen-xi-ding-wei/</id>
        <link href="https://flyer88.github.io/post/nei-cun-xie-lu-fen-xi-ding-wei/">
        </link>
        <updated>2020-06-15T15:43:54.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>内存泄露根本原因</strong></li>
<li><strong>内存泄露常见情况</strong></li>
<li><strong>内存泄露定位方案</strong></li>
<li><strong>最近碰到的示例</strong></li>
<li><strong>常见内存泄露解决方案</strong></li>
</ul>
<blockquote>
<p>该章节需配合 <code>Java GC</code> 机制 一起看</p>
</blockquote>
<h3 id="0x0001-内存泄露根本原因">0x0001. 内存泄露根本原因</h3>
<ol>
<li>
<p><strong><code>GCRoot</code> 对象长期持有其他已经无用的对象（本该被回收，却未被回收）</strong>。通俗的说就是 <strong>生命周期较长的对象（如 static 类）持有生命周期较短的对象的引用（某个 Activity）</strong></p>
</li>
<li>
<p><code>GCRoot</code> 对象包括</p>
<ol>
<li>
<p>方法区静态属性 ，常量（多数伴随整个虚拟机的生命周期）</p>
</li>
<li>
<p>栈帧中本地变量表中的引用对象 （即当前线程正在运行的代码持有的对象）</p>
</li>
<li>
<p>JNI 本地方法引用的对象 （native 区引用的对象）</p>
</li>
</ol>
</li>
</ol>
<h3 id="0x0002-内存泄露常见情况">0x0002. 内存泄露常见情况</h3>
<ol>
<li>
<p>静态对象</p>
<ul>
<li>
<p><code>static activity</code></p>
</li>
<li>
<p><code>static view</code></p>
</li>
</ul>
</li>
<li>
<p><code>activity/fragment</code> 销毁，结束耗时任务(异步网络请求)</p>
</li>
<li>
<p><code>inner class</code> 存在异步等情况</p>
</li>
<li>
<p><code>SingleInstance</code> 持有局部生命周期 <code>Activity</code></p>
</li>
<li>
<p>资源类 <code>cursor</code> 没有关闭</p>
</li>
</ol>
<blockquote>
<p>补充，<code>lamda</code> 表达式是匿名内部类</p>
</blockquote>
<h3 id="0x0003-内存泄露定位方案">0x0003. 内存泄露定位方案</h3>
<ol>
<li>
<p>静态分析</p>
<p>跑 <code>Lint</code>，注意看 <code>Warning</code> ，会针对 <code>handler</code> 等，进行提示</p>
</li>
<li>
<p>动态分析</p>
<ul>
<li><code>leakCanary</code></li>
<li><code>adb shell dumpsys meminfo [PackageName]</code></li>
<li><code>Android Profiler</code> (见下方内存泄露实例详解)</li>
</ul>
<p>以上三者，根据个人经验可以结合起来使用</p>
<ol>
<li><code>leakCanary</code> 可以用于快速定位内存泄露问题</li>
<li>当面对 <code>leakCanary</code> 无法直接确定内存泄露的时，可以用 <code>adb shell dumpsys</code> 进行辅助确认泄露 <code>activity</code></li>
<li>根据前两者确定的 <code>activity</code> 配合 <code>Android Profiler</code> <code>GC</code> 后进行分析，查看没有回收的对象的引用链，即可定位内存泄漏位置</li>
</ol>
</li>
</ol>
<h3 id="0x0004-最近碰到的示例">0x0004.  最近碰到的示例</h3>
<p>​	背景介绍： 一个商品详情页，有内存泄露 。</p>
<ol>
<li>
<p><code>LeakCanary</code>  报错截图，发现是一个 <code>UI</code> 消息队列上的一条消息泄露了，无法直接定位具体代码。<br>
<img src="https://flyer88.github.io/post-images/1592235944966.png" alt="img" loading="lazy"></p>
</li>
<li>
<p>此时，利用 <code>adb shell dumpsys meminfo</code>，然后多次进出 <code>SpuDetailActivity</code> ，验证确认是 <code>SpuDetailActivity</code> 存在泄露。</p>
</li>
</ol>
<pre><code class="language-shell">➜ adb shell dumpsys meminfo com.leixun.taofen8.haoda
Applications Memory Usage (in Kilobytes):
Uptime: 693212294 Realtime: 787382396

** MEMINFO in pid 14754 [com.leixun.taofen8.haoda] **
                   Pss  Private  Private  SwapPss     Heap     Heap     Heap
                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
  Native Heap    74230    74108        0      230    98688    86999    11688
  Dalvik Heap     6442     5952        0       25    11519     5760     5759
 Dalvik Other     2683     2680        0        4
        Stack       84       84        0        0
       Ashmem        2        0        0        0
      Gfx dev    28316    28316        0        0
    Other dev       28        0       28        0
     .so mmap    15415      280     7720        7
    .jar mmap     3762        0     1844        0
    .apk mmap      432        0      132        0
    .ttf mmap      107        0       48        0
    .dex mmap    19419    19344       32        0
    .oat mmap      621        0        4        0
    .art mmap     4696     4108        0        9
   Other mmap     5421      476     3348        0
      Unknown     2842     2808        0        6
        TOTAL   164781   138156    13156      281   110207    92759    17447

 App Summary
                       Pss(KB)
                        ------
           Java Heap:    10060
         Native Heap:    74108
                Code:    29404
               Stack:       84
            Graphics:    28316
       Private Other:     9340
              System:    13469

               TOTAL:   164781       TOTAL SWAP PSS:      281

 Objects
               Views:      341         ViewRootImpl:        2
         AppContexts:        7           Activities:        2
              Assets:       18        AssetManagers:        0
       Local Binders:       25        Proxy Binders:       37
       Parcel memory:       11         Parcel count:       48
    Death Recipients:        2      OpenSSL Sockets:       13
            WebViews:        0

 SQL
         MEMORY_USED:        0
  PAGECACHE_OVERFLOW:        0          MALLOC_SIZE:        0
 
 Asset Allocations
      : 162K
</code></pre>
<ol start="3">
<li>
<p>由于个人经验丰富，直接借助 <code>LeakCanary</code> 和 <code>adb shell dumpsys meminfo</code> 配合几次试错，定位到问题</p>
<blockquote>
<p>整个推导流程：</p>
<p><code>UI</code> -&gt; <code>Handler</code> -&gt; <code>MutableLiveData</code> -&gt; <code>MutableLiveData.observe()</code></p>
<p><code>UI</code> 消息发送，自己代码中没有 <code>handler</code> 之类的，用了只有 <code>MutableLiveData</code> 来更新 <code>View</code>，快速定位两个 <code>LiveData Observe</code> 的代码，配合 <code>adb shell dumpsys meminfo</code> 直接验证注释掉几个方法，看 <code>Activity</code> 数量，快速定位出问题出在 <code>spuDetailBinding.hdPtrList.refreshComplete()</code>， 该第三方库调用错误时会出现内存泄露。</p>
</blockquote>
<pre><code class="language-java">...       
  viewModel.loadSuccess.observe(this, aBoolean -&gt; {
      	if (aBoolean) {
      		adapter.submitList(viewModel.itemViewModels);
      	}
      	hideProgressDialog();
      	spuDetailBinding.hdPtrList.refreshComplete();
   });
   viewModel.loadRelatedSuccess.observe(this, aBoolean -&gt; {
       adapter.submitList(viewModel.itemViewModels);
   });
 ...
</code></pre>
</li>
<li>
<p><code>Android Profiler</code> 内存进行举例性分析，定位问题所在</p>
</li>
</ol>
<blockquote>
<p>使用 <code>profiler</code> 的时候，最好把 <code>leakCanary</code> 去掉，影响手动 <code>GC</code>，而且还会引起卡顿</p>
<p>不熟练 <code>profiler</code>，可以配合 <a href="https://developer.android.com/studio/profile/memory-profiler">Android Profiler 官方使用指南</a>食用</p>
</blockquote>
<ol>
<li>
<p><strong>连接 <code>profiler</code></strong><br>
<img src="https://flyer88.github.io/post-images/1592235971126.png" alt="😀" loading="lazy"><br>
​</p>
</li>
<li>
<p><strong>手动触发<code>GC</code></strong><br>
<img src="https://flyer88.github.io/post-images/1592235992860.png" alt="😁" loading="lazy"></p>
</li>
<li>
<p><strong>选中内存区域，找到泄露的 <code>Activity</code></strong><br>
<img src="https://flyer88.github.io/post-images/1592236015842.png" alt="😂" loading="lazy"></p>
</li>
<li>
<p>根据之前 <code>LeakCanary</code> 报错，直接定位 <code>MessageQueue</code> 持有的对象<br>
<img src="https://flyer88.github.io/post-images/1592236028325.png" alt="🤣" loading="lazy"></p>
</li>
</ol>
<h3 id="0x0005-常见内存泄露解决方案">0x0005. 常见内存泄露解决方案</h3>
<ol>
<li><code>WeakReference</code> 进行包裹</li>
<li>用谷歌官方提供的生命周期组件，类似 <code>MutableLiveData</code> 之类的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】如何实现 RxJava 的链式调用 -- flatmap 方法的实现]]></title>
        <id>https://flyer88.github.io/post/jiu-ru-he-shi-xian-rxjava-de-lian-shi-diao-yong-flatmap-fang-fa-de-shi-xian/</id>
        <link href="https://flyer88.github.io/post/jiu-ru-he-shi-xian-rxjava-de-lian-shi-diao-yong-flatmap-fang-fa-de-shi-xian/">
        </link>
        <updated>2020-06-15T10:39:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2017年 05 月 24 日</p>
</blockquote>
<pre><code class="language-java">public interface Api{
    void queryPhoto(String query,QueryCallback QueryCallback);
    void store(Photo photo,StoreCallback storeCallback);
    interface QueryCallback{
        void onQuerySuccess(List&lt;Photo&gt; photoList);
        void onQueryFailed(Exception e);
    }
    interface StoreCallback{
        void onCatStored(Uri uri);
        void onStoredFailed(Exception e);
    }
}
</code></pre>
<pre><code class="language-java">RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = new RxJob&lt;List&lt;Photo&gt;&gt;(){
  				@Override
                public void doJob(final RxCallback&lt;List&lt;Photo&gt;&gt; rxCallback) {
                    mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
                        @Override
                        public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                            rxCallback.onNext(photoList);
                        }
                      

                        @Override
                        public void onQueryFailed(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }
            };
};

RxJob&lt;List&lt;Photo&gt;&gt; storePhotoJob = new RxJob&lt;Uri&gt;() {
            @Override
            public void doJob(RxCallback&lt;Uri&gt; rxCallback) {
                mApi.store(photo, new Api.StoreCallback() {
                    @Override
                    public void onCatStored(Uri uri) {
                        rxCallback.onNext(uri);
                    }

                    @Override
                    public void onStoredFailed(Exception e) {
			rxCallback.onError(e);
                    }
                });
            }
        };


queryPhotoJob.map(photoList -&gt; { return getBestPhoto(photoList);})
  	.flatMap(photo -&gt; { return storePhotoJob;} )
	.map(photo -&gt; {return photo.getUrl();})
	.doJob(new RxCallback&lt;String&gt;() {
            @Override
            public void onNext(String s) {
		ToastUtils.show(s);
            }

            @Override
            public void onError(Exception e) {
		ToastUtils.show(e);
            }
   });
</code></pre>
<pre><code class="language-java">public abstract class RxJob&lt;T&gt;{
	public abstract void doJob(RxCallback&lt;T&gt; rxCallback){}
  	public RxJob map(){
        final RxJob&lt;T&gt; curJob = this;
        return new RxJob&lt;R&gt;() {
            @Override
            public void doJob(final RxCallback&lt;R&gt; rxCallback) {
                curJob.doJob(new RxCallback&lt;T&gt;() {
                    @Override
                    public void onNext(T t) {
                        R mapped = func.call(t);
                        rxCallback.onNext(mapped);
                    }

                    @Override
                    public void onError(Exception e) {
                        rxCallback.onError(e);
                    }
                });
            }
        };
    }
  	public RxJob flatMap(){...};
}
</code></pre>
<h3 id="flatmap-的实现"><code>flatMap</code> 的实现</h3>
<p>前一篇文章介绍了链式调用的形成以及 <code>map</code> 方法的实现，<code>map</code> 方法实现的是 T -&gt; R 的类型转换</p>
<blockquote>
<p><a href="https://gist.github.com/flyer88/5d7129fc2ca9010ff6109a81157fbafa">如何实现 RxJava 的链式调用 -- map 方法的实现</a></p>
</blockquote>
<p>但如果 <code>map</code> 方法中需要实现 一个异步方法呢？</p>
<pre><code class="language-java">queryPhotoJob.map(photoList -&gt; { return getBestPhoto(photoList);})
		.map(photo -&gt; {mApi.store(photo)} )
  		.map(uri -&gt; {loadImage(uri)})
</code></pre>
<p>注意 <code>mApi.store(photo)</code> 是异步任务，无法直接返还一个<code>uri</code> 类型。</p>
<p>于是需要用到 <code>flatMap</code> 方法。</p>
<p><code>flatMap</code> 同样需要用到 <code>R call(T t)</code> 这个转变函数</p>
<blockquote>
<p><strong>首先回头考虑，我们最开始的第一个异步方法是如何实现的，也就是 <code>queryPhotoJob</code> 的创建</strong></p>
<p><strong>执行是在 <code>doJob()</code> 方法中执行了 <code>mApi.queryPhoto()</code> 然后调用 <code>rxCallback.onNext()</code> 继续往下走</strong></p>
</blockquote>
<p>代码如下：</p>
<pre><code class="language-java">RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = new RxJob&lt;List&lt;Photo&gt;&gt;(){
  				@Override
                public void doJob(final RxCallback&lt;List&lt;Photo&gt;&gt; rxCallback) {
                    mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
                        @Override
                        public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                            rxCallback.onNext(photoList);
                        }
                      

                        @Override
                        public void onQueryFailed(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }
            };
};
</code></pre>
<p>由此考虑，<code>flatMap</code> 方法中也可以把那个异步方法处理成一个 <code>RxJob</code> 对象</p>
<p>然后让他把回调往返还的 <code>new RxJob()</code> 中的 <code>doJob</code> 方法中 的 <code>Callback</code> 往下一个 <code>RxJob</code> 传递</p>
<pre><code class="language-java">public &lt;R&gt; RxJob&lt;R&gt; flatMap(final Func&lt;T,RxJob&lt;R&gt;&gt; func){
    final RxJob&lt;T&gt; curJob = this;
    return new RxJob&lt;R&gt;() {
        @Override
        public void doJob(final RxCallback&lt;R&gt; rxCallback) {
            curJob.doJob(new RxCallback&lt;T&gt;() {
                @Override
                public void onNext(T t) {
                    // 此处是最大的区别,外部函数的转换
                    RxJob&lt;R&gt; flatMapped = func.call(t);
                  	// 得到 flatMapped ，然后调用
                    flatMapped.doJob(new RxCallback&lt;R&gt;() {
                        @Override
                        public void onNext(R r) {
                            // 把需要变换出的类型往下一个任务传递
                          	// 此处和 map 方法处理一致
                            rxCallback.onNext(r);
                        }

                        @Override
                        public void onError(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }

                @Override
                public void onError(Exception e) {
                    rxCallback.onError(e);
                }
            });
        }
    };
}
</code></pre>
<h3 id="map-和-flatmap-的对比"><code>map</code> 和 <code>flatMap</code> 的对比</h3>
<p><code>flatMap</code> 和 <code>map</code> 最大的区别就是返还的 <code>RxJob</code> 对象中 <code>curJob.doJob</code> 中回调的区别</p>
<p><code>flatMap</code> 方法核心部分</p>
<pre><code class="language-java"> // 此处是最大的区别
 RxJob&lt;R&gt; flatMapped = func.call(t);
 flatMapped.doJob(new RxCallback&lt;R&gt;() {
   @Override
   public void onNext(R r) {
   	rxCallback.onNext(r);
   }

  @Override
  public void onError(Exception e) {
       rxCallback.onError(e);
  }
});
</code></pre>
<p><code>map</code> 方法核心部分</p>
<pre><code class="language-java">R mapped = func.call(t);
rxCallback.onNext(mapped);
</code></pre>
<p><code>flatMap</code> 在回调完以后，运行的是 <code>flatMapped.doJob()</code></p>
<p>并且把当前 <code>RxJob</code> 对象 <code>rxCallback</code> 的回调放到了<code>flatMapped.doJob</code> 中的回调用</p>
<p>从而使得下一个数据 <code>r</code> 是在运行完 <code>flatMapped</code> 任务后生成的。</p>
<p>代入此处就是 <code>r</code> 就是 <code>mApi.store(photo,callback)</code> 中的 <code>photo</code></p>
<h3 id="解释为什么-map-函数无法实现-flatmap-的功能">解释为什么 <code>map</code> 函数无法实现 <code>flatMap</code> 的功能？</h3>
<p><code>flatMap</code> 中的转变函数的具体实现是 <code>T -&gt; RxJob&lt;R&gt;</code> 的转换</p>
<p>带入当前例子就是 <code>Photo —&gt; RxJob&lt;String&gt;</code></p>
<p>注意，之前的 <code>map</code> 方法是 <code>List —&gt; Photo</code>  而不是 <code>List&lt;Photo&gt; -&gt; Photo</code></p>
<p>因为 <code>map</code> 方法的入参是 <code>Func&lt;T,R&gt; func</code> ，而不是 <code>Func&lt;List&lt;T&gt;,R&gt; func</code></p>
<p>而 <code>flaMap</code> 函数的入参则是 <code>Func&lt;T,RxJob&lt;R&gt;&gt; func</code>,写死了第二个参数类型必须是 <code>RxJob&lt;R&gt;</code> ，然后 <code>RxJob&lt;R&gt;</code> 方法会被执行</p>
<p>做到了异步中的异步，同样也说明了入参 <code>Func&lt;?,?&gt; func</code> 会决定转换函数的功能，从而影响整个变换的不同</p>
<p><code>map</code> 和 <code>flatMap</code> 的区别就如下图</p>
<pre><code>					map
	  A ------------&gt;  B/[B]		
    
												
					flatMap							
	 [A]------------&gt; [B]									 

</code></pre>
<p>​</p>
<p>其核心在于类型的变换，即 <code>Func&lt;?,?&gt; func</code>也就是函数式编程中的 <code>Functor</code></p>
<p>不同的 <code>func</code> 就会实现不同的变换， <code>flatMap</code> 就是一个 <code>Monad</code></p>
<p>当其运用到 <a href="https://github.com/ReactiveX">ReactiveX</a> 上时，其转换核心就是数据流，也就做到了 <code>Observe/Subscribe</code> 的模式，因为在每一次变换后数据始终存在，对应的操作也可触发。不过 <code>RxJava</code> 还有更多其他的东西，不仅仅是这两个变换。但基本上理解这两个变换就能举一反三了，理解其他变换</p>
<p><code>RxJava</code> 中的 <code>map/flatMap</code> 也是创建对于的 <code>Observable</code> 对象，然后调用对应的函数，然后返回需要的数据</p>
<p>其中 <code>map</code> 方法中的入参 <code>Function</code>，只会在各种类型中转换</p>
<p>而 <code>flatMap</code> 中的入参 <code>Function</code> 必然会转换出一个 <code>Observable&lt;R&gt;</code> 类型</p>
<p>在 <code>RxJava 2</code> 转换出的是一个 <code>ObservableSource&lt;R&gt;</code></p>
<p>官方解释如下，non-backpressured Observable，可以理解为类似 <code>Observable</code> 类型，此处和 <code>backpressured</code> 的一些概念有关联，不作解释。</p>
<blockquote>
<p>Represents a basic, non-backpressured {@link Observable} source base interface</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】如何实现 RxJava 的链式调用 -- map 方法的实现]]></title>
        <id>https://flyer88.github.io/post/jiu-ru-he-shi-xian-rxjava-de-lian-shi-diao-yong-map-fang-fa-de-shi-xian-md/</id>
        <link href="https://flyer88.github.io/post/jiu-ru-he-shi-xian-rxjava-de-lian-shi-diao-yong-map-fang-fa-de-shi-xian-md/">
        </link>
        <updated>2020-06-15T10:32:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2017年 05 月 24 日</p>
</blockquote>
<pre><code class="language-java">public interface Api{
    void queryPhoto(String query,QueryCallback QueryCallback);
    interface QueryCallback{
        void onQuerySuccess(List&lt;Photo&gt; photoList);
        void onQueryFailed(Exception e);
    }
}
</code></pre>
<pre><code class="language-java">public class PhotoUtils{
    Api mApi;
    public void handlePhotoSync(){
        mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
            @Override
            public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                Photo photo = getBestPhoto(photoList);
              	String imgUrl = photo.getUrl();
            }

            @Override
            public void onQueryFailed(Exception e) {
				ToastUtils.show(e);
            }
        });
    }
}
</code></pre>
<p><strong>此时假设有一个包裹类，他可以运行 <code>getBestPhoto(photoList)</code> 和 <code>photo.getUrl()</code> 这两行代码，而这两行代码由外部放入</strong></p>
<p>那么调用就会如下：</p>
<pre><code class="language-java">RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = new RxJob&lt;List&lt;Photo&gt;&gt;(){
  				@Override
                public void doJob(final RxCallback&lt;List&lt;Photo&gt;&gt; rxCallback) {
                    mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
                        @Override
                        public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                            rxCallback.onNext(photoList);
                        }
                      

                        @Override
                        public void onQueryFailed(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }
            };
};
  // 如果有这么一个包裹类，代码就可以写成下面这样，则当需要调用的时候，
  // 代码就会和 RxJava 很类似( java 8 上会变成 Lambda 表达式 )
  // 从而使得代码具有很清晰的逻辑，异步代码看上去也会变的如同步代码一样。
queryPhotoJob
  .map(photoList -&gt; { return getBestPhoto(photoList);})
  //.map(new Func&lt;List&lt;Photo&gt;,Photo&gt;()
  //          @Overide
  //          Photo call(List&lt;Photo&gt; photoList){
  //		    return getBestPhoto(photoList);
  //		  })
  .map(photo -&gt; {return photo.getUrl()})
  .doJob(new RxCallback&lt;T&gt;() {
            @Override
            public void onNext(T t) {

            }

            @Override
            public void onError(Exception e) {

            }
   });
</code></pre>
<p>因此接下来需要考虑如何实现这个包裹的类，使得其调用会像  <code>RxJava</code> 一般。首先需要确定该类需要处理以下几个问题</p>
<ul>
<li>该包裹的类有哪些方法及其使用</li>
<li><code>map</code> 函数如何实现，其调用逻辑</li>
</ul>
<h3 id="整体介绍">整体介绍：</h3>
<p>确定一个包裹类 —&gt; 创建包裹类 <code>new RxJob()</code> —&gt; <code>map</code> 方法实现</p>
<h3 id="map-方法实现包括"><code>map</code> 方法实现包括 ：</h3>
<p>入参和出参的基本类型确定 —&gt; 转变函数的确定  —&gt; <code>doJob</code> 调用 —&gt; <code>map</code> 返还值具体介绍 —&gt; <code>func.call()</code> 返还值的传递</p>
<h3 id="包裹类方法和作用">包裹类方法和作用</h3>
<p>首先取名，该类叫 <code>RxJob</code></p>
<p><code>RxJob</code> 类的意义，它被定义成一个任务，类似 <code>AsyncTask</code> ，而运行该任务的方法就是 <code>doJob</code> 有入参 <code>RxCallback</code></p>
<p>类的定义还有一个泛型 <code>T</code> ，主要决定了 <code>doJob</code> 方法中 <code>RxCallback&lt;T&gt;</code> 中的 <code>T</code> 类型</p>
<p>该类型会影响很多部分的参数类型，具体需要参考后面的分析。</p>
<p>代码如下:</p>
<pre><code class="language-java">public abstract class RxJob&lt;T&gt; {
    public abstract void doJob(RxCallback&lt;T&gt; rxCallback);
    public &lt;R&gt; RxJob&lt;T&gt; map(final Func&lt;T,R&gt; func){...}
}
</code></pre>
<p>先忽略 <code>map</code> 方法，现看 <code>doJob(RxCallback&lt;T&gt; rxCallback)</code></p>
<p><code>doJob(RxCallback&lt;T&gt; rxCallback)</code> 有一个回调，回调接口定义如下：</p>
<pre><code class="language-java">public interface RxCallback&lt;T&gt; {
    void onNext(T t);
    void onError(Exception e);
}
</code></pre>
<p>两个方法，<code>onNext(T t)</code> 和 <code>onError(Exception e)</code> ,一个用来传递内容 <code>T</code>，一个用来处理错误</p>
<p>也就是说，<code>RxJob</code> 执行的内容最终都是 <code>doJob(RxCallback&lt;T&gt; rxCallback)</code> 方法，这个方法是链接起所有回调的核心</p>
<p>保证了所有的方法能一个一个根据链式调用一个一个执行</p>
<h3 id="创建包裹类-new-rxjob">创建包裹类 <code>new RxJob(..)</code></h3>
<p>直接带入当前的栗子中，代码如下</p>
<pre><code class="language-java">RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = new RxJob&lt;List&lt;Photo&gt;&gt;(){
  	        @Override
                public void doJob(final RxCallback&lt;List&lt;Photo&gt;&gt; rxCallback) {
                    mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
                        @Override
                        public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                            rxCallback.onNext(photoList);
                        }
                      

                        @Override
                        public void onQueryFailed(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }
            };
};
</code></pre>
<p>其中<code>RxJob&lt;T&gt;</code> 中的 <code>T</code> 的值是 <code>List&lt;Photo&gt;</code>，这主要决定于 <code>mApi.queryPhoto()</code> 中 <code>onQuerySuccess(List&lt;Photo&gt; photoList)</code> 中的参数类型，让 <code>rxCallback.onNext(photoList)</code> 能取到对应的类型。从而把拿到的数据内容，借助 <code>RxCallback</code> 回调往外层抛出。</p>
<p>即，如果我们需要调用 <code>queryPhotoJob</code> ，让他执行对应的操作代码如下</p>
<pre><code class="language-java">queryPhotoJob.doJob(new RxCallback&lt;List&lt;Photo&gt;&gt;(){
  	public void onNext(List&lt;Photo&gt; photoList){
           Photo photo = getBestPhoto(photoList);
           String imgUrl = photo.getUrl();
  	}
  	public void onError(Exception e){...}
});
</code></pre>
<h3 id="核心部分-map-函数如何实现">核心部分 map 函数如何实现</h3>
<p>首先可以确定的是 map 函数返回的类型肯定是 <code>RxJob</code>，因为 <code>map</code>方法是可以连续调用的，</p>
<p>其次，可以确定 <code>map</code> 函数的入参是 <code>Func</code>，</p>
<p>一个匿名内部类（<code>Java 8</code> 中的 <code>Lambda</code> 表达式），在其他某些语言中就是函数对象、函数引用之类的</p>
<p>由此可以确定 <code>map</code> 方法基本的样子如下代码：</p>
<pre><code class="language-java">public RxJob map(Func&lt;T,R&gt; func){
  	...
    return rxJob;
};
</code></pre>
<p>然后考虑入参 <code>Func&lt;T,R&gt; func</code> 的实现，即这个转变函数该如何实现。</p>
<h4 id="1-转变函数的确定">1. 转变函数的确定</h4>
<p>首先可以确定这个匿名内部类会实现一个从 <code>T 类型—&gt; R 类型</code>的转换，</p>
<p>其次 <code>func</code> 对象是在 map 方法调用的时候，才确定具体的实现内容，因此，它必然是一个接口或者抽象方法，待实现</p>
<p>然后，考虑到 <code>T 类型—&gt; R 类型</code> 的转换在具体代码编写的时候是可以确定的，由此考虑可以用泛型方法和泛型类就可以实现。</p>
<p>从而创建 <code>Func&lt;T,R&gt;</code> 接口，该接口有一个 <code>R call(T t)</code> 方法待实现</p>
<p>看如下代码：</p>
<pre><code class="language-java">public interface Func&lt;T,R&gt; {
    /**
     *
     * @param t transform 的对象类型
     * @return 返还的对象类型
     */
    R call(T t);
}
</code></pre>
<p>该方法返回的类型，是泛型类 <code>Func&lt;T,R&gt;</code> 中的 <code>R</code>，其入参是泛型类 <code>Func&lt;T,R&gt;</code> 中的 <code>T</code></p>
<p>即该类的作用就是进行一个从 <code>T —&gt; R</code> 的转换，而具体的转换方法由外部实现。</p>
<p>应用到上面的例子就是，<code>List —&gt; Photo</code> 的转换，即 <code>R call&lt;T t&gt;</code> 方法 变成了 <code>Photo call&lt;List photoList&gt;</code></p>
<p>于是乎，代码就变成了如下的样子</p>
<pre><code class="language-java">RxJob queryPhotoJob = new RxJob(..)...;
queryPhotoJob
  .map(new Func&lt;List&lt;Photo&gt;,Photo&gt;()
            @Overide
            Photo call(List&lt;Photo&gt; photoList){
			    return getBestPhoto(photoList);
  			})
  // 同理第二个 map 就成了如下，
  // 入参是上个操作的出参 Photo
  // 而出参则是 String 类型的
  .map(new Func&lt;Photo,String&gt;(){
            @Overide
            String call(Photo photo){
                return photo.getUrl()//返还 String 类型
            }
          })
  .doJob(...);
</code></pre>
<p>至此，<code>map</code> 函数的入参整体已经介绍完毕。</p>
<h4 id="2dojob-方法的调用">2.<code>doJob</code> 方法的调用</h4>
<p>然后考虑里面具体的调用逻辑，首先考虑任务调用，第一个 <code>map</code> 方法在触发的时候，<code>queryPhotoJob</code> 本身已经是一个 <code>RxJob</code> 对象了</p>
<p>它的实现内容也简单，在创建包裹类时已经有解释了。</p>
<pre><code class="language-java">queryPhotoJob.doJob(new RxCallback&lt;List&lt;Photo&gt;&gt;(){
  	public void onNext(List&lt;Photo&gt; photoList){..}
  	public void onError(Exception e){...}
});
</code></pre>
<p>也就是说，如果我要调用 <code>map</code> 方法触发传入的 <code>func</code> 匿名内部类，就必须先调用 <code>queryPhotoJob.doJob(..)</code></p>
<p>于是把代码变成</p>
<pre><code class="language-java">public RxJob map(Func&lt;T,R&gt; func){
  rxJob.doJob(new RxCallback&lt;T&gt;() {
      @Override
      public void onNext(T t) {
      }

      @Override
      public void onError(Exception e) {
      }
    });
  return ...;
};
</code></pre>
<p>应用到上述例子中其具体的泛型值变化就成了如下代码</p>
<pre><code class="language-java">public RxJob map(Func&lt;List&lt;Photo&gt;,R&gt; func){
  rxJob.doJob(new RxCallback&lt;List&lt;Photo&gt;&gt;() {
      @Override
      public void onNext(List&lt;Photo&gt; photoList) {
      }

      @Override
      public void onError(Exception e) {
      }
    });
  return ...;
};
</code></pre>
<p>此时需要考虑的就是在哪里调用 <code>func</code> 函数，它是负责把<code>T —&gt; R</code> ，</p>
<p>因此该部分代码必然是在当前任务执行完后，拿到当前任务的回调值，然后进行转换，即 <code>map</code> 方法会变成如下</p>
<pre><code class="language-java">public RxJob map(Func&lt;T,R&gt; func){
  rxJob.doJob(new RxCallback&lt;T&gt;() {
      @Override
      public void onNext(T t) {
        R mapped = func.call(t);
      }

      @Override
      public void onError(Exception e) {
      }
    });
  return ...;
};
</code></pre>
<h4 id="3-map-方法返还值">3. <code>map</code> 方法返还值</h4>
<p>接下来考虑返回值，首先 <code>map</code> 方法返回的是一个 <code>RxJob</code>对象</p>
<p>其次，因为当前任务已经执行完了，而下一个任务需要当前任务执行后处理的返回值，即<code>func.call(t)</code> 返回的 <code>mapped</code> 值</p>
<p>如果返回的是原有的 <code>RxJob</code> 那么每次调用 <code>map</code> 方法时执行的代码永远是 <code>this.doJob</code> 因此每次执行的内容都是第一个任务了</p>
<p>应用到此处就是 <code>queryPhotoJob.doJob(..)</code>。</p>
<p>因此 <code>map</code> 方法返回的值应该是一个新创建的 <code>RxJob</code> 对象，并且该对象的 <code>doJob</code> 方法会先运行当前任务的 <code>doJob</code> 方法</p>
<p>代码如下：</p>
<pre><code class="language-java">public RxJob map(Func&lt;T,R&gt; func){
  	 RxJob curJob = this;
      return new RxJob() {
            @Override
            public void doJob(final RxCallback rxCallback) {
                curJob.doJob(new RxCallback&lt;T&gt;() {
                    @Override
                    public void onNext(T t) {
                        R mapped = func.call(t);
                      	...
                    }

                    @Override
                    public void onError(Exception e) {
                        ...
                    }
                });
            }
        };
};
</code></pre>
<p>把当前例子的泛型值带入如下：</p>
<pre><code class="language-java">public RxJob map(Func&lt;List&lt;Photo&gt;,R&gt; func){
  	 RxJob queryPhotoJob = this;
     RxJob mapJob = new RxJob() {
            @Override
            public void doJob(final RxCallback rxCallback) {
                queryPhotoJob.doJob(new RxCallback&lt;List&lt;Photo&gt;&gt;() {
                    @Override
                    public void onNext(List&lt;Photo&gt; photoList) {
                        R mapped = func.call(photoList);
                      	...
                    }

                    @Override
                    public void onError(Exception e) {
                        ...
                    }
                });
            }
        };
  return mapJob;
};
</code></pre>
<h4 id="4-funccall-的返还值传递">4. <code>func.call()</code> 的返还值传递</h4>
<p>考虑如何把 <code>func.call()</code> 调用后的返回的数据往下一个 <code>RxJob</code> 传递</p>
<p>直接调用下一个 <code>RxJob</code> 中回调的 <code>rxCallback.onNext()</code>方法即可，对于错误也同样调用 <code>rxCallback.onError(e)</code> 即可。</p>
<pre><code class="language-java">public RxJob map(Func&lt;T,R&gt; func){
  	 RxJob curJob = this;
      return new RxJob() {
            @Override
            public void doJob(final RxCallback rxCallback) {
                curJob.doJob(new RxCallback&lt;T&gt;() {
                    @Override
                    public void onNext(T t) {
                        R mapped = func.call(t);
                      	rxCallback.onNext(t);
                    }

                    @Override
                    public void onError(Exception e) {
                        rxCallback.onError(e);
                    }
                });
            }
        };
}
</code></pre>
<p>代入当前例子：</p>
<pre><code class="language-java">public RxJob map(Func&lt;List&lt;Photo&gt;,R&gt; func){
  	 RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = this;
     RxJob mapJob = new RxJob() {
            @Override
            public void doJob(final RxCallback mapJobCallback) {
                queryPhotoJob.doJob(new RxCallback&lt;List&lt;Photo&gt;&gt;() {
                    @Override
                    public void onNext(List&lt;Photo&gt; photoList) {
                        R mapped = func.call(photoList);
                      	mapJobCallback.onNext(mapped);
                    }

                    @Override
                    public void onError(Exception e) {
                        mapJobCallback.onError(e);
                    }
                });
            }
        };
  return mapJob;
}
</code></pre>
<p>最终只需要确定泛型参数类型 <code>R</code>，他的作用是确定下一个<code>RxJob</code> 对象的泛型值</p>
<p><code>R</code> 由 <code>func.call()</code> 方法 确定，也就是之前说的，在具体的 <code>map</code> 方法被调用时，参数的泛型值是可以确定的</p>
<p><code>Func</code> 函数负责把 T —&gt; R 转换，因此，最终的 <code>map</code> 方法如下：</p>
<pre><code class="language-java">public &lt;R&gt; RxJob&lt;R&gt; map(Func&lt;T,R&gt; func){
      RxJob curJob = this;
      return new RxJob&lt;R&gt;() {
            @Override
            public void doJob(final RxCallback&lt;R&gt; rxCallback) {
                curJob.doJob(new RxCallback&lt;T&gt;() {
                    @Override
                    public void onNext(T t) {
                        R mapped = func.call(t);
                        rxCallback.onNext(mapped);
                    }

                    @Override
                    public void onError(Exception e) {
                        rxCallback.onError(e);
                    }
                });
            }
        };
  }
</code></pre>
<p>应用到当前例子，带入泛型值如下</p>
<pre><code class="language-java">public&lt;Photo&gt; RxJob&lt;Photo&gt; map(Func&lt;List&lt;Photo&gt;,Photo&gt; func){
  	 RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = this;
     RxJob&lt;Photo&gt; mapJob = new RxJob&lt;Photo&gt;() {
            @Override
            public void doJob(final RxCallback&lt;Photo&gt; mapJobCallback) {
                queryPhotoJob.doJob(new RxCallback&lt;List&lt;Photo&gt;&gt;() {
                    @Override
                    public void onNext(List&lt;Photo&gt; photoList) {
                        Photo mapped = func.call(photoList);
                      	mapJobCallback.onNext(mapped);
                    }

                    @Override
                    public void onError(Exception e) {
                        mapJobCallback.onError(e);
                    }
                });
            }
        };
  return mapJob;
}
</code></pre>
<h3 id="整个任务如何运行">整个任务如何运行</h3>
<pre><code class="language-java">RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = new RxJob&lt;List&lt;Photo&gt;&gt;(){
  				@Override
                public void doJob(final RxCallback&lt;List&lt;Photo&gt;&gt; rxCallback) {
                    mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
                        @Override
                        public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                            rxCallback.onNext(photoList);
                        }
                      

                        @Override
                        public void onQueryFailed(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }
            };
};
RxJob&lt;Photo&gt; bestPhotoJob = queryPhotoJob.map(photoList -&gt; { return getBestPhoto(photoList);})
RxJob&lt;String&gt; urlJob = .map(photo -&gt; {return photo.getUrl();})
urlJob.doJob(new RxCallback&lt;String&gt;() {
            @Override
            public void onNext(String s) {
				ToastUtils.show(s);
            }

            @Override
            public void onError(Exception e) {
				...
            }
   });
</code></pre>
<p>解释代码，第一个 <code>map</code> 方法 返还了一个 <code>RxJob&lt;Photo&gt;</code> 对象，第二个 <code>map</code> 返还了一个 <code>RxJob&lt;String&gt;</code> 对象，第三个 <code>doJob</code> 方法触发整个任务</p>
<p><code>doJob</code> 方法触发的第一个方法是 <code>urlJob</code> 中的 <code>doJob</code> 方法，由于 <code>urlJob</code> 对象是由 <code>map</code> 方法创建的</p>
<p>因此，在执行 <code>ToastUtils.show(s)</code> 方法之前，会先执行 <code>bestPhotoJob.doJob()</code></p>
<p>同样，<code>queryPhotoJob.doJob()</code>也会执行在 <code>bestPhotoJob.doJob()</code> 方法之前</p>
<p>因此整体过程就是 <code>queryPhotoJob.doJob()</code>—&gt; <code>bestPhotoJob.doJob()</code> —&gt; <code>urlJob.doJob()</code></p>
<p>而这执行过程中，<code>R mapped = func.call(T)</code> 会先被调用，因此单个 <code>RxJob</code> 调用链如下：</p>
<blockquote>
<p>在调用每个 <code>RxJob.onNex()</code>情况下(即成功的情况下，没有出错)</p>
</blockquote>
<p><code>queryPhotoJob.doJob()</code> : <code>mApi.query</code> —&gt; <code>func.call(t)</code> —&gt; <code>getBestPhoto(photoList)</code></p>
<p><code>bestPhotoJob.doJob()</code> ： <code>func.call(t)</code> —&gt; <code>photo.getUrl()</code></p>
<p><code>urlJob.doJob()</code>：  <code>ToastUtil.show()</code></p>
<p>比较炫酷的写法如下：</p>
<pre><code class="language-java">RxJob&lt;List&lt;Photo&gt;&gt; queryPhotoJob = new RxJob&lt;List&lt;Photo&gt;&gt;(){
  				@Override
                public void doJob(final RxCallback&lt;List&lt;Photo&gt;&gt; rxCallback) {
                    mApi.queryPhoto(&quot;flyer&quot;, new Api.QueryCallback() {
                        @Override
                        public void onQuerySuccess(List&lt;Photo&gt; photoList) {
                            rxCallback.onNext(photoList);
                        }
                      

                        @Override
                        public void onQueryFailed(Exception e) {
                            rxCallback.onError(e);
                        }
                    });
                }
            };
};
queryPhotoJob
  .map(photoList -&gt; { return getBestPhoto(photoList);})
  .map(photo -&gt; {return photo.getUrl()})
  .doJob(...);
</code></pre>
<p>=================================</p>
<p><a href="">异步里面还有异步方法，<code>flatMap</code> 待续</a></p>
<p>=================================</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】Android 贝塞尔曲线，QQ 删除小红点类似效果实现]]></title>
        <id>https://flyer88.github.io/post/jiu-android-bei-sai-er-qu-xian-qq-shan-chu-xiao-hong-dian-lei-si-xiao-guo-shi-xian/</id>
        <link href="https://flyer88.github.io/post/jiu-android-bei-sai-er-qu-xian-qq-shan-chu-xiao-hong-dian-lei-si-xiao-guo-shi-xian/">
        </link>
        <updated>2020-06-15T09:50:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2015 年 11 月 16 日</p>
</blockquote>
<p>具体的实现</p>
<ul>
<li>首先偏移量</li>
<li>然后是计算贝塞尔曲线</li>
<li>接下来就是计算控制点o,p<br>
看到 QQ 拖动删除小红点的动画效果，就想着做个类似的效果，没找到Android 版的教程，于是就自己撸了一个，代码地址：https://github.com/flyer88/JellyCircle/tree/master/circleindicator ，该栗子的实现在circleIndicator包中，app包下是另一个demo，还没写好。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://flyer88.github.io/post-images/1592214669097.gif" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://flyer88.github.io/post-images/1592214679012.gif" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://flyer88.github.io/post-images/1592214687544.gif" alt="img" loading="lazy"></figure>
<p>注意：为实现上面链接中所示的动画，首先确定，两个圆随着偏移量的改变，半径大小出现了变化，同时贝塞尔曲线有所变化，那剩下的问题就是如何改变两个圆的半径大小，圆的位置，同时计算和绘制贝塞尔曲线</p>
<h1 id="接下来看具体的实现">接下来看具体的实现</h1>
<h3 id="首先偏移量">首先偏移量</h3>
<p>我此处给的值比较简单，直接通过<code>SeekBar</code>来获取偏移量</p>
<p>获取偏移量后，需要改变的数据有，半径大小，以及第二个圆的位置，以及贝塞尔曲线的重新绘制</p>
<p>具体代码如下：</p>
<pre><code>    mEndCircle.setX(dpToPx(mDefaultFirstX + mMaxDistance * offset,getResources()));//修改第二个圆的位置
    mEndCircle.setRadius(dpToPx(mDefaultMinRadius,getResources()) + offset * dpToPx(mDefaultMaxRadius - mDefaultMinRadius,getResources()));//第二个圆半径变大
    mStartCircle.setRadius(dpToPx(mDefaultMaxRadius,getResources()) - offset * dpToPx(mDefaultMaxRadius - mDefaultMinRadius,getResources()));//第一个圆半径变小
    mCanDrawBezier = calculatePoint(mStartCircle, mEndCircle);//计算贝塞尔曲线
    invalidate();//刷新，触发onDraw()，重新绘制
</code></pre>
<h3 id="然后是计算贝塞尔曲线">然后是计算贝塞尔曲线</h3>
<p>看下图，基本上可以确定出有两条曲线，我没有画两条曲线，而是一条<code>mBezierPath</code>搞定</p>
<p>A-&gt;B-&gt;C-&gt;D-&gt;A（关于控制点哦o,p后面会有计算分析，基本按照上图中所写就可以计算出o,p两点的位置）</p>
<figure data-type="image" tabindex="4"><img src="https://flyer88.github.io/post-images/1592214698011.jpg" alt="img" loading="lazy"></figure>
<p>其中，A点是开始点，直接 <code>moveTo()</code> 即可，然后用<code>lineTo()</code>到B点,再调用系统自带的贝塞尔曲线方法<code>quadTo(ponitP.x,pointP.y)</code>计算即可，然后就是一样的<code>lineTo()</code>到D点，<code>quadTo(pointO.x,pointP.y)</code>;</p>
<p>关于<code>quadTo(x1,y1,x2,y2)</code>的使用，可以去百度一下，简单说一下，就是前面两个是控制点，后面两个是到达的点</p>
<p>这样<code>mBezierPath</code>基本就画好了，然后画起始圆和结束圆就可以了（当然，如果考虑到overdraw的话，起始可以用clipRect clipReject去掉重复的半圆，此处偷懒，直接画了两个圆，没有去掉重复绘制，或者直接画一个半圆，当然半圆的效果和圆是不一样的）</p>
<p>以下是构建出<code>mBezierPath</code>的代码</p>
<pre><code>    mBezierPath.reset();
    mBezierPath.moveTo(mStartA.getX(), mStartA.getY());
    mBezierPath.lineTo(mStartB.getX(), mStartB.getY());
    mBezierPath.quadTo(mControlPointP.getX(), mControlPointP.getY(), mEndC.getX(), mEndC.getY());
    mBezierPath.lineTo(mEndD.getX(), mEndD.getY());
    mBezierPath.quadTo(mControlPointO.getX(), mControlPointO.getY(), mStartA.getX(), mStartA.getY());
</code></pre>
<h3 id="接下来就是计算控制点op">接下来就是计算控制点o,p</h3>
<p>以图二简单的为例子，这种方式比较极端，计算比较容易，两个控制点p,o和H点重合，直接(R1(x,y)+R2(x,y))/2 = H(x,y)</p>
<p>图一也不麻烦，根据图一标注θ也可以算出o,p两点的x,y,具体实现可以看github代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】Android 代码混淆(二)]]></title>
        <id>https://flyer88.github.io/post/jiu-android-dai-ma-hun-yao-er/</id>
        <link href="https://flyer88.github.io/post/jiu-android-dai-ma-hun-yao-er/">
        </link>
        <updated>2020-06-15T09:48:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2016 年 08 月 13 日</p>
</blockquote>
<ul>
<li>基本操作及整体的流程</li>
<li>注意事项
<ul>
<li>warning 处</li>
<li>多个 module 的混淆</li>
<li>反射的处理</li>
<li>JavaScript 的处理</li>
<li>常用系统和第三方库的混淆规则</li>
<li>@keep 注解来避开混淆</li>
</ul>
</li>
</ul>
<p>Android 代码混淆(一) 中已经记录并走了混淆的整个流程，用命令行进行混淆的操作，并验证了三个过程，这篇文章会记录一下在 <code>Android Studio</code> 下混淆的操作，以及具体需要的注意的一些事项。</p>
<h4 id="基本操作及整体的流程">基本操作及整体的流程</h4>
<p>1.修改<code>build.gradle</code>脚本</p>
<pre><code>    buildTypes {
            release {
                minifyEnabled true//开启混淆
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//配置内容
            }
            debug {
                minifyEnabled true//开启混淆
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//配置内容
            }
        }
</code></pre>
<p>2.修改proguard-rules.pro文件，写入基础的几个混淆规则，避开<code>Android</code>自带的一些类</p>
<pre><code>    # 四大组件及基本类
    -keep public class * extends android.app.Activity
    -keep public class * extends android.app.Application
    -keep public class * extends android.app.Service
    -keep public class * extends android.content.BroadcastReceiver
    -keep public class * extends android.content.ContentProvider
    -keep public class * extends android.app.backup.BackupAgentHelper
    -keep public class * extends android.preference.Preference
    -keep public class com.android.vending.licensing.ILicensingService
    -keep public class * extends android.app.Fragment
    -keep public class * extends android.support.v4.**
    -keep public class * extends android.support.annotation.**
    -keep public class * extends android.support.v7.**
    -keep public class android.app.Notification
    -keep public class android.webkit.**
    #保护WebView对HTML页面的API不被混淆
    -keep class **.Webview2JsInterface {*; }
    -keep public class * extends android.app.Dialog
    -keep public class * extends android.view

    # 所有枚举类型不要混淆
    -keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
    }

    # 保持 native 方法不被混淆
    -keepclasseswithmembernames class * {
    native &lt;methods&gt;;
    }

    #保持R文件不被混淆，否则，你的反射是获取不到资源id的
    -keep class **.R*{*;}

    # parcelable 不被混淆
    -keep class * implements android.os.Parcelable {
    public static finalandroid.os.ParcelableCreator *;
    }

    #保持实现&quot;Serializable&quot;接口的类不被混淆
    -keepnames class * implements java.io.Serializable

    #保护实现接口Serializable的类中，指定规则的类成员不被混淆
    -keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    !static !transient &lt;fields&gt;;
    !private &lt;methods&gt;;
    !private &lt;methods&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
    }
</code></pre>
<p>3.直接跑一个debug版的进行测试，把打包好的APK修改成.zip文件，解压，取出文件中dex包。</p>
<figure data-type="image" tabindex="1"><img src="https://flyer88.github.io/post-images/1592214577248.jpg" alt="img" loading="lazy"></figure>
<p>把解压获取的<code>dex</code>文件，通过 <a href="https://github.com/pxb1988/dex2jar">dex2jar工具</a> (一个把<code>dex</code>包转换成<code>jar</code>包的工具)，把<code>dex</code>转换成<code>jar</code>包。其具体使用不在此详细讲。</p>
<p>下图中我没有把d2j-dex2jar配置进环境变量，所以进入对应目录跑的脚本。</p>
<figure data-type="image" tabindex="2"><img src="https://flyer88.github.io/post-images/1592214586829.jpg" alt="img" loading="lazy"></figure>
<p>运行完后可以看到，当前目录下多了一个<code>classes-dex2jar.jar</code>的文件</p>
<figure data-type="image" tabindex="3"><img src="https://flyer88.github.io/post-images/1592214601165.jpg" alt="img" loading="lazy"></figure>
<p>接下来就是和前一篇文章一样，直接用<code>Intelij</code>导入，看class文件，包内类名字已有变化，部分类已被移除，同时部分类也被改成final类型。具体就不上图了。主要看下面的注意事项。</p>
<h4 id="注意事项">注意事项</h4>
<p>上述流程在如果是项目一开始就进行混淆，大部分情况下是能够成功混淆，并且不会出现很大问题，只需要在项目进行过程中注意，新加的第三方类库，反射代码。但是，如果你面对的是一个沉积已久，并且项目庞大，而又从未写过混淆的项目，那你可能会在混淆开启时，面临几千个混淆时的<code>warning</code>和<code>note</code>，最终无法编译通过。这中间主要是大量第三方库的报错。下面记录一下我在处理这种情况时，遇到的问题以及解决方案</p>
<h5 id="warning-处理">warning 处理</h5>
<p>写了个<a href="https://github.com/flyer88/Some_Python_For_Android">脚本</a>,，过滤出大部分错误，生成proguard文件，然后继续处理剩下的个别遗留问题</p>
<p>写几个典型的例子：</p>
<p>1.情况一:</p>
<pre><code>    Note: xxxxxx calls 'Class.getEnclosingMethod'
    #这种情况就是调用了反射，找到xxxxx对应调用的类，并且设为入口点 
</code></pre>
<p>2.情况二:</p>
<pre><code>    Warning: AAAAAAA: can't find superclass or interface BBBBBBB
    Warning: AAAAAAA: can't find referenced class BBBBBBB 
    #这两种种情况就是找不到BBBBBB了，直接把BBBBB设为入口点，同时给AAAAA打上-dontwarn既可以,如下
    -keep class BBBBBB
    -dontwarn AAAAAA
</code></pre>
<p>3.情况三:</p>
<pre><code>    Note:AAAAA accesses a declared field BBBBB dynamically 
        Maybe this is program field 'CCCCC'
        Maybe .....
    #这种情况下，需要处理CCCC,把它设为入口点，同样设置对AAAAA设置-dontwarn
    -keep class CCCCC
    #不一定是-keep，也有可能其他的，例如 -keepattribute 更为合适
    -dontwarn AAAAA
</code></pre>
<h5 id="多个-module-的混淆">多个 module 的混淆</h5>
<p>有时候会碰到多个<code>module</code>混淆的情况,多数情况下，为了清晰处理会给每个<code>module</code>都写上对应的混淆规则，同时需要修改<code>build.gradle</code>的配置，而不是之前的写法，具体可以参考<a href="http://stackoverflow.com/questions/30820915/android-studio-proguard-handling-in-multi-library-projects">so上的解释</a></p>
<p>这种方案，需要<code>module</code>之间的依赖清晰，最底层的<code>module</code>会被最先混淆，然后一步一步倒推上去，知道主<code>module</code>,多为<code>app module</code>。</p>
<pre><code>    buildTypes {
        release {
            consumerProguardFiles 'proguard-project.txt'
        }
    }
</code></pre>
<p>然而，我碰到的情况则是，多个<code>module</code>中有相同的包名，这时候视图去每个<code>module</code>自顾自混淆的情况下是不可能。因为同包名的情况下，混淆器是无法一个一个<code>module</code>的进行混淆。</p>
<p>所以最终的解决方案是，面对这种项目，还是在主<code>module</code>中进行混淆吧。</p>
<h5 id="反射的处理">反射的处理</h5>
<p>反射举个例子：</p>
<pre><code>    Class&lt;?&gt; a = Class.forName(&quot;com.dove.xu.a&quot;);
    -keep class com.dove.xu.a{*;}    
</code></pre>
<p>不过，此处在考虑到自己代码的同时，需要注意第三方类库。类似的<code>json</code>处理库，<code>retrofit</code>等都是有反射代码的。</p>
<h5 id="javascript-的处理">JavaScript 的处理</h5>
<p>处理方案和上面的反射类似</p>
<p>keep 掉需要调用 java 代码方法，或者类即可</p>
<p>举个栗子：</p>
<pre><code>    public class  WebInterface{
        WebInterface(){
        }    

        @JavascriptInterface
        public void callBackAndroid(){
            Toast.make....
        }
    }
</code></pre>
<p>混淆规则只需要加上</p>
<pre><code>    -keep class com.dove.xu.WebInterface{*;}
</code></pre>
<h5 id="常用系统和第三方库的混淆规则">常用系统和第三方库的混淆规则</h5>
<p>下面这个github库收藏了大量第三方库的混淆规则，可以去看一下</p>
<p><a href="https://github.com/krschultz/android-proguard-snippets">snippets</a></p>
<p>基本的系统混淆规则，在一开始则整体流程中也已记录，就不重复了。</p>
<p>最后，需要注意的是网上也会有大量现成的第三方类库的混淆规则。但是在抄的时候也需要注意，不同的版本混淆规则不一定相同，所以一定要注意，在拷贝完以后，看一下规则，是否符合自己的版本，包名是否正确。</p>
<p>举个自己碰到的例子：</p>
<p><a href="https://github.com/JakeWharton/butterknife/blob/master/butterknife/proguard-rules.txt">Butterknife 8.2.1 混淆规则,摘自官方github</a></p>
<pre><code>    # Retain generated class which implement ViewBinder.
    -keep public class * implements butterknife.internal.ViewBinder { public &lt;init&gt;(); }

    # Prevent obfuscation of types which use ButterKnife annotations since the simple name
    # is used to reflectively look up the generated ViewBinder.
    -keep class butterknife.*
    -keepclasseswithmembernames class * { @butterknife.* &lt;methods&gt;; }
    -keepclasseswithmembernames class * { @butterknife.* &lt;fields&gt;; }
</code></pre>
<p><a href="https://github.com/chalup/proguard-please-repo/blob/master/com.jakewharton/butterknife/5.1.2/proguard.cfg">Butterknife 5.1.2 混淆规则，摘自官方github</a></p>
<pre><code>    -dontwarn butterknife.internal.**
    -keep class **$$ViewInjector { *; }
    -keepnames class * { @butterknife.InjectView *;}
</code></pre>
<p>注:此处因学长提到<code>@</code>的问题，后来查看官方文档，如下:</p>
<p>The @ specifications can be used to restrict classes and class members to the ones that are annotated with the specified annotation types. An annotationtype is specified just like a classname.</p>
<p>上面大概的意思就是说，@符号可以用来标记注解类，用法和一般类一样</p>
<p>即，</p>
<pre><code>-keepnames class * { @butterknife.InjectView *;}
</code></pre>
<p>此处的意思是，避开所有类中，有<code>butterknife.InjectView</code>注解的任何变量，方法等，其中<code>butterknife</code>是指包名，即<code>InjectView</code>的完整引用，参考下图：</p>
<figure data-type="image" tabindex="4"><img src="https://flyer88.github.io/post-images/1592214617147.jpg" alt="img" loading="lazy"></figure>
<h5 id="keep-注解来避开混淆">@keep 注解来避开混淆</h5>
<pre><code>//防止混淆类
@Keep
public class Person {}

//防止混淆变量
@Keep
public String name;

//防止混淆方法
@Keep
public int getAge(){}
</code></pre>
<p>需要手动开启注解避开混淆</p>
<pre><code>#http://tools.android.com/tech-docs/support-    annotations
-dontskipnonpubliclibraryclassmembers
-printconfiguration
-keep,allowobfuscation @interface         android.support.annotation.Keep

-keep @android.support.annotation.Keep class *
-keepclassmembers class * {
    @android.support.annotation.Keep *;
}
</code></pre>
<hr>
<p>以上就是我在Android混淆时，学到的知识以及碰到的问题。特此记录</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】Android 代码混淆(一)]]></title>
        <id>https://flyer88.github.io/post/jiu-android-dai-ma-hun-yao-yi/</id>
        <link href="https://flyer88.github.io/post/jiu-android-dai-ma-hun-yao-yi/">
        </link>
        <updated>2020-06-15T09:46:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2016 年 08 月 13 日</p>
</blockquote>
<ul>
<li>介绍
<ul>
<li>
<ul>
<li>反射(该部分内容具体处理和理解，会在下一文章中进行具体的记录)</li>
</ul>
</li>
</ul>
</li>
<li>具体的使用
<ul>
<li>
<ul>
<li>Obfuse 步骤验证</li>
<li>Optimize 步骤验证</li>
<li>Shrink 步骤验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>本文对照 <a href="http://proguard.sourceforge.net/">Proguard 的文档</a>进行翻译同时加上个人的理解，如果有与原文不同，请以原文为主。</p>
<hr>
<h2 id="介绍">介绍</h2>
<p>混淆器(ProGuard)会对 Java class 文件进行 shrinker(压缩)，optimizer(优化)，obfuscator(混淆)以及preverifier(校验)。shrinker(压缩)这一步会找到并移除没用到的类，变量，方法，属性。optimization(优化)这一步，会分析并且优化方法的字节码。obfuscation(混淆)则会对 class，fields，methods替换成一些短的无意义的名字。第一步会把代码量变小，运行更加有效率，同时更加难以被逆向。在 Java Micro Edition 和 Java 6或者更高版本中，最后一步的检验过程，会向class文件中添加一些预校验的信息。</p>
<p>上述的每个步骤，都是可以选择的(可以进行也可以不进行)。例如，ProGuard 可以只进行preverify，从而更高效的运行。</p>
<figure data-type="image" tabindex="1"><img src="https://flyer88.github.io/post-images/1592214415502.jpg" alt="img" loading="lazy"></figure>
<ul>
<li>首先，ProGuard(混淆器) 读入输入的 jars (也可以是 aars, wars, ears, zips, apks, 或者目录)。随后，开始进行 shrinker(压缩)，optimizer(优化)，obfuscator(混淆)以及preverifier(校验)。你可以选择性的让ProGuard(混淆器)进行多种类型的优化操作。ProGuard(混淆器)会把修改过的结果写入一个或者多个输出的 jars (也可以是 aars, wars, ears, zips, apks, 或者目录)中。</li>
<li>混淆器需要明确输入文件(Input jars)是jars包(也可以是 aars, wars, ears, zips, apks, 或者目录)。这些 libraries 本质上是你将会用来编译的代码。混淆器为了能够正确进行整个过程，会重新构建类之间的依赖。而依赖包(Library jars) 往往是不会被改变的，但你依旧需要把它们放在最终的App的环境中。 #### Entry points(入口点)</li>
<li>在压缩步骤(shrinker)，混淆器会从这些点(入口点)进入，并且递归寻找决定哪些类和哪些类成员会被使用。所有的其他类和类成员都会被抛弃掉</li>
<li>在优化步骤(optimizer)，混淆器会进一步优化代码。在这些优化过程中，那些不是入口点的类和方法会变成private static或者final，不被用到的参数会被移除，一些方法会变成内敛方法</li>
<li>在混淆这一步(obfuscator)，混淆器会重新命名那些不是入口点的类和类的成员。在这整个过程中，那些成为入口点的地方，依旧会为他们保留原来的名字</li>
<li>预验证阶段(preverifier)是唯一一个不需要知道入口点的阶段</li>
</ul>
<h4 id="反射该部分内容具体处理和理解会在下一文章中进行具体的记录">反射(该部分内容具体处理和理解，会在下一文章中进行具体的记录)</h4>
<ul>
<li>对于反射和introspection 进行代码的自动处理时，都会存在一些特殊的问题。在混淆器进行处理时，代码中类和类成员都是被动态创建或者被动态调用的(通过对应类的名字，或者成员名字)，这些地方都必须被定义成入口点。例如，<code>Class.forName()</code>这个构造器会在运行时指向任何的类。又比如，类的名字可能会从配置文件中读入，这通常很难去计算出是那些类需要被保留(通过原始的名字)。因此，你必须得在混淆器的配置中，通过简单相同的操作<code>-keep</code>来指定他们。 然而，混淆器已经能够帮你发现并处理以下的情况： <code>Class.forName(&quot;SomeClass&quot;)</code> <code>SomeClass.class</code> <code>SomeClass.class.getField(&quot;someField&quot;)</code> <code>SomeClass.class.getDeclaredField(&quot;someField&quot;)</code> <code>SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] {})</code> <code>SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] { A.class })</code> <code>SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] { A.class, B.class })</code> <code>SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] {})</code> <code>SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] { A.class })</code> <code>SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] { A.class, B.class })</code> <code>AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, &quot;someField&quot;)</code> <code>AtomicLongFieldUpdater.newUpdater(SomeClass.class, &quot;someField&quot;)</code> <code>AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, &quot;someField&quot;)</code></li>
<li>类和类成员的名字会不一样，但是构造方法必然是相同的，由此，混淆器能够认出他们。被引用的类和类的成员在压缩(shrinking)阶段会被保留，同时，string 类型的参数也会在混淆时(obfuscation)被准确的修改。</li>
<li>除此之外，混淆器会提供一些建议：是否保留一些出现的类和类成员。举例，混淆器会标记<code>(SomeClass)Class.forName(variable).newInstance()</code>这样的构造器。因为这些方法可能会指向其他类，这些可能是类，也可能是接口，或者是继承自这些接口或者类的类。你需要在配置中做相应的处理。</li>
<li>为了能够得到正确的混淆结果，你应该对进行混淆的代码多少有所熟悉。当面临大量反射代码时，混淆代码需要进行大量的试验，并处理错误，特别是对于内部代码没有足够的信息的情况下</li>
</ul>
<hr>
<p>以上是对<a href="http://proguard.sourceforge.net/">官方文档首页</a>的翻译内容</p>
<h2 id="具体的使用">具体的使用</h2>
<p>该部分不是翻译内容，是根据<a href="http://proguard.sourceforge.net/manual/usage.html">ProGuard 的使用方法</a>和<a href="http://proguard.sourceforge.net/">文档首页</a>，对上述三个步骤的具体验证。</p>
<p>由于大部分情况下，Android 的混淆只需要考虑 Obfuse 这个步骤，因为很多第三方依赖包的混淆规则会把 shrink 和 optimize 去掉（比如友盟）。所以先验证这一步。</p>
<h4 id="obfuse-步骤验证">Obfuse 步骤验证</h4>
<p>这个步骤，如上所说，主要是对类，方法进行名字的修改，也是 Android 混淆中最重要的部分。为了验证这个过程，我做了下面的demo操作</p>
<ul>
<li>首先写了3个类：</li>
</ul>
<pre><code>    package com.dove.home;

    class HelloWorld {
        public HelloWorld(){
            System.out.println(&quot;Hello World&quot;);
        }
    }
    package com.dove.home;

    class HelloWorld2 {
        public HelloWorld2(){
            System.out.println(&quot;Hello World2&quot;);
        }
    }
    package com.dove.home;

    class Main {
        public static void main(String[] args) {
            HelloWorld helloWorld = new HelloWorld();
        }
    }
</code></pre>
<ul>
<li>然后编译,打包</li>
</ul>
<pre><code>    javac com/dove/home/Main.java
    javac com/dove/home/HelloWorld2.java
    javac com/dove/home/HelloWorld.java
    //注意在进行下面步骤的时候，我把 com/dove/home 下的 java源码删了
    jar -cvf main_source.jar com
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://flyer88.github.io/post-images/1592214446516.jpg" alt="img" loading="lazy"></figure>
<ul>
<li>然后使用混淆器，混淆器其具体使用方法，主要是调用 proguard.jar 包，然后配置 proguard.pro 文件进行具体的参数设置。</li>
</ul>
<pre><code>java -jar proguard.jar @proguard.pro
</code></pre>
<p>下面是我 proguard.pro 文件内容</p>
<pre><code># 源码文件
-injars main_source.jar
# 混淆后输出文件
-outjars main_source_out.jar
# java 核心 jar 不能混淆
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars &lt;java.home&gt;/lib/jce.jar
# 全部不混淆，即三个class文件都会保持原样
-keep class com.dove.home.Main{*;}
-keep class com.dove.home.HelloWorld{*;}
-keep class com.dove.home.HelloWorld2{*;}
</code></pre>
<blockquote>
<p>注意：然后修改 proguard.pro 文件，内容如下,生成另一个混淆后的包</p>
</blockquote>
<pre><code>-injars main_source.jar
# 注意输出包的名字改了
-outjars main_source_proguard_out.jar
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars &lt;java.home&gt;/lib/jce.jar
-keep class com.dove.home.Main{*;}
# 删除了HelloWorld的 keep
-keep class com.dove.home.HelloWorld2{*;}
</code></pre>
<p>最后对代码逆向，进行验证，最快的方式是把生成的 jar 包，当做第三方依赖包直接导入Intellij 中(有decode的功能)，如下图，三个包的区别</p>
<figure data-type="image" tabindex="3"><img src="https://flyer88.github.io/post-images/1592214471667.jpg" alt="img" loading="lazy"></figure>
<p>最初是的源码包和保留<code>HelloWorld</code>,<code>HelloWorld2</code>以及<code>Main</code>入口点的包是一样的，不同的是最后没有保留<code>HelloWorld</code>入口点的包，它的<code>HelloWorld</code>变成了<code>a</code>，而<code>Main</code>和<code>HelloWorld2</code>都正常没有被修改</p>
<h4 id="optimize-步骤验证">Optimize 步骤验证</h4>
<p>同样，修改 proguard.pro 文件</p>
<pre><code>-injars main_source.jar
# 输出包名改了，方便对比
-outjars main_source_proguard_not_optimize_out.jar
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars &lt;java.home&gt;/lib/jce.jar
# 加上不进行优化的限制
-dontoptimize
-keep class com.dove.home.Main{*;}
-keep class com.dove.home.HelloWorld2{*;}
</code></pre>
<p>同上，导入IntelliJ，对比上一步中混淆后的 jar 包，发现名字没啥变化，但内容不一样了</p>
<figure data-type="image" tabindex="4"><img src="https://flyer88.github.io/post-images/1592214485831.jpg" alt="img" loading="lazy"></figure>
<p>首先是没有添加 <code>-dontoptimize</code></p>
<pre><code>package com.dove.home;

final class a {
    public a() {
        System.out.println(&quot;Hello World&quot;);
    }
}
</code></pre>
<p>然后是添加了 <code>-dontoptimize</code></p>
<pre><code>package com.dove.home;

class a {
    public a() {
        System.out.println(&quot;Hello World&quot;);
    }
}
</code></pre>
<p>如上述译文中所说，optimize 会进行代码优化，不是入口点的代码，会变成<code>final</code>，<code>private</code>等等</p>
<h4 id="shrink-步骤验证">Shrink 步骤验证</h4>
<p>修改 proguard.pro 文件，进行压缩，同时不对 HelloWorld，HelloWorld2进行入口点的保留</p>
<pre><code>-injars main_source.jar
-outjars main_source_proguard_shrink_out.jar
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars &lt;java.home&gt;/lib/jce.jar

-keep class com.dove.home.Main{*;}
# 注意对比之前，删除了HelloWorld和HelloWorld2的 keep
</code></pre>
<p>修改 proguard.pro 文件，不进行压缩，同样不对 HelloWorld，HelloWorld2进行入口点的保留</p>
<pre><code>-injars main_source.jar
-outjars main_source_proguard_not_shrink_out.jar
-libraryjars &lt;java.home&gt;/lib/rt.jar
-libraryjars &lt;java.home&gt;/lib/jce.jar
# 添加不进行压缩
-dontshrink
-keep class com.dove.home.Main{*;}
</code></pre>
<p>其结果对比</p>
<p>添加了 <code>-dontshrink</code>标志</p>
<figure data-type="image" tabindex="5"><img src="https://flyer88.github.io/post-images/1592214500132.jpg" alt="img" loading="lazy"></figure>
<p>未添加 <code>-dontshrink</code>标志</p>
<figure data-type="image" tabindex="6"><img src="https://flyer88.github.io/post-images/1592214511632.jpg" alt="img" loading="lazy"></figure>
<p>由此验证，shrink阶段，Proguard(混淆器)会把无用类文件等删除，一些被动态获取的类就需要注意了，需要进行<code>-keep</code>操作</p>
<hr>
<p>以上就是对混淆整个过程的验证</p>
<p>对于 Android 混淆，一些需要注意的东西，会在下一篇文章中记录</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】记录一些蛋疼的bug(二)]]></title>
        <id>https://flyer88.github.io/post/jiu-ji-lu-yi-xie-dan-teng-de-buger/</id>
        <link href="https://flyer88.github.io/post/jiu-ji-lu-yi-xie-dan-teng-de-buger/">
        </link>
        <updated>2020-06-15T09:45:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2016 年 07 月 15 日</p>
</blockquote>
<p>1.<code>int</code> -2^32 到 2^32，<code>long</code> -2^63 到 2^63-1，这种问题大部分在时间戳碰到，需注意</p>
<pre><code class="language-java">public static void main(String[] args) {
    int time = 1470022057;//注意是int类型
    System.out.println(formatLongToDate(time));//传入的是int，参数是long不会超出int长度
    System.out.println(format(new Date(time * 1000),&quot;MM月dd日 HH:mm&quot;));//传入的是int，秒级时间戳，位数刚好和int类型的位数相同，所以会爆，所以转换会出错
} 
public static String formatLongToDate(long time){
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM月dd日 HH:mm&quot;);
    Date date= new Date(time * 1000);
    String result = sdf.format(date);
    return result;
}
public static String format(Date date, String regex) {
    DateFormat df = new SimpleDateFormat(regex);
    return df.format(date);
}
</code></pre>
<p>上述运行结果</p>
<pre><code>08月01日 11:27
01月14日 13:34
</code></pre>
<ol>
<li>关于<code>targetSdkVersion</code>(<a href="http://gold.xitu.io/entry/5690e33460b20f9aeaa3f085/view">几个code的区别</a>)降级问题，降级会带来很多未知问题。用户安装了<code>targetSdkVersion</code>是<code>23</code>版本的<code>app</code>，而下一个版本把<code>targetSdkVersion</code>改为了<code>22</code>，首先，第一个问题就是会导致用户无法安装，需要卸载后重装。初次之外，降级也会导致对一些<code>API</code>调用不正常。</li>
<li>同时修改了多个<code>module</code>的<code>gradle</code>文件，出现了以下问题<code>Error:Timeout waiting to lock cp_proj class cache for</code>删除报错的cache文件夹即可</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】记录一些蛋疼的bug(一)]]></title>
        <id>https://flyer88.github.io/post/jiu-ji-lu-yi-xie-dan-teng-de-bugyi/</id>
        <link href="https://flyer88.github.io/post/jiu-ji-lu-yi-xie-dan-teng-de-bugyi/">
        </link>
        <updated>2020-06-15T09:45:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2015年 12 月 21 日</p>
</blockquote>
<ol>
<li>
<p>主题适配时，drawable 错误 ...... Caused by: android.content.res.Resources$NotFoundException: File res/drawable/menu_shape.xml from drawable resource ID #0x7f020179 ...... Caused by: java.lang.UnsupportedOperationException: Can't convert to color: type=0x2</p>
<p>drawable 中 对 attr color 进行引用导致报错</p>
<p>具体看 https://code.google.com/p/android/issues/detail?id=26251</p>
<p>Android 系统 的 bug，color 无法被引用到drawable中，只能一个主题一个drawable，5.0以上修复此bug</p>
</li>
<li>
<p>相册问题</p>
<p>不同版本下，系统相册的位置是不同的，建议创建一个自己的文件夹，具体操作，通过<code>Environement.get..</code>来获取系统环境下的sd卡目录，然后创建文件夹</p>
</li>
</ol>
<pre><code>Intent intent = newIntent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);//系统拍照
intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1);//画质
intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);//保存到uri
Environment.getExternalStorageDirectory();//获取uri时，用这个方法，不然容易不同版本不问题
</code></pre>
<ol start="3">
<li>XwalkView（14）截图问题</li>
</ol>
<p>http://stackoverflow.com/questions/29483028/how-can-i-capture-the-whole-view-into-a-bitmap-when-using-crosswalk-to-display-w</p>
<p>http://www.cnblogs.com/ct2011/p/4100132.html</p>
<p>注意：</p>
<ul>
<li>
<p><code>XWalkPreferences.setValue(XWalkPreferences.ANIMATABLE_XWALK_VIEW, true)</code>需要在load之前就设置,在<code>activity</code> 的<code>onCreate()</code>设置，<code>onDestroy()</code> 中去除</p>
</li>
<li>
<p>获取<code>TextureView</code>:</p>
<pre><code>private TextureView findXWalkTextureView(ViewGroup group) {
       int childCount = group.getChildCount();
       for (int i = 0; i &lt; childCount; i++) {
           View child = group.getChildAt(i);
        if (child instanceof TextureView) {
            String parentClassName = child.getParent().getClass().toString();
            boolean isRightKindOfParent = (parentClassName.contains(&quot;XWalk&quot;));
            if (isRightKindOfParent) {
                return (TextureView) child;
            }
        } else if (child instanceof ViewGroup) {
            TextureView textureView = findXWalkTextureView((ViewGroup) child);
            if (textureView != null) {
                return textureView;
            }
        }
    }
    return null;
}
</code></pre>
</li>
<li>
<p>截图：</p>
<pre><code>public Bitmap captureImage(XWalkView xWalkView) {

if (xWalkView != null) {
    Bitmap bitmap = null;

    boolean isCrosswalk = false;
    try {
        Class.forName(&quot;org.xwalk.core.XWalkView&quot;);
        isCrosswalk = true;
    } catch (Exception e) {
        e.printStackTrace();
    }

    if (isCrosswalk) {
        try {
            TextureView textureView = findXWalkTextureView(xWalkView);
            bitmap = textureView.getBitmap();
        } catch (Exception e) {
            e.printStackTrace();
        }
    } else {
        bitmap = Bitmap.createBitmap(xWalkView.getWidth(), xWalkView.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(bitmap);
        xWalkView.draw(c);
    }
    return bitmap;
    } else {
        return null;
    }
    }
</code></pre>
</li>
</ul>
<ol start="4">
<li>popwindow 和 menu物理键 第二次无法触发，以及第二次直接弹出并且隐藏问题<br>
主要原因是，popwindow 添加了window从而截取了menu事件，所以activity处无法获取<br>
http://www.bkjia.com/Androidjc/988767.html<br>
Activity 代码：</li>
</ol>
<pre><code>@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {

    switch (keyCode) {
    case KeyEvent.KEYCODE_MENU:
        isMenuShow = true;
        showPopupWindow();
        break;
    }
    return super.onKeyDown(keyCode, event);
}
</code></pre>
<p>showPopupWindow:</p>
<pre><code>    private void showPopupWindow() {
        View view = inflater.inflate(R.layout.popupwindow, null);
        ll.setOnKeyListener(new OnKeyListener() {
            @Override
            public boolean onKey(View v, int keyCode, KeyEvent event) {
                if (keyCode == KeyEvent.KEYCODE_MENU) {
                    if (!isMenuShow) {
                        popupWindow.dismiss();
                    }
                    isMenuShow = false;
                }
                return false;
            }
        });
</code></pre>
<ol>
<li>Android appcompat-v7 兼容包导致 MENU 按键不能监听到的解决方案</li>
</ol>
<p>https://twiceyuan.com/2015/05/07/Android-appcompat-v7-兼容包导致-MENU-按键不能监听到的解决方案/</p>
<ol>
<li>
<p>bug 5.0 以上 button 中设置 text 英文状态下会变成大写<br>
解决方法：<code>android:textAllCaps=&quot;false&quot;</code></p>
</li>
<li>
<p>Android 6.0（23） 源码中，String类的实现被替换了，具体调用的时候，会调用一个StringFactory来生成一个String，不过一直没有找到入口</p>
<pre><code> public String(char[] data) {
throw new UnsupportedOperationException(&quot;Use StringFactory instead.&quot;);
}
</code></pre>
<p>除此之外，android 下 String 类实现与 Oracle 的实现完全不一样</p>
</li>
<li>
<p>全球化问题，语言切换<br>
<code>compileSdkVersion 23</code><br>
版本的时候需要<br>
<code>resources.updateConfiguration(config, dm);</code><br>
不然没用<br>
http://blog.csdn.net/sodino/article/details/6596709</p>
</li>
<li>
<p>三星的傻逼，拍照会旋转，导致原<code>activity</code>重生，从而触发<code>onCreate()</code><br>
在<code>AndroidManifest.xml</code>对应的<code>activity</code>写上 · <code>android:screenOrientation=&quot;landscape&quot;</code><br>
（landscape = 横向 portrait = 纵向）<br>
<code>android:configChanges=&quot;keyboardHidden|orientation&quot;</code></p>
</li>
<li>
<p>遇到一个傻逼的bug，前几天还可以构建，放完假以后，运行项目突然报错，应该与我用的studio beat 版相关：<br>
报错为：<code>Plugin is too old,please update to a more recent version,or set ANDROID_DAILY_OVERRIDE environment variable to &quot;XXXXX&quot;</code><br>
点下面的<code>Fix plugin version and sync project</code>依旧报错，无用。<br>
后来发现是build.gradle 里classpath的问题 我用的是 2.0.0 alpha1 改成1.2.3<br>
或者改成最新的 alpha3，等待下载重新构建就可以了<br>
<code>com.android.tools.build:gradle:1.2.3</code><br>
建议用1.2.3，alpha3需要更新2.8的gradle，又要更新，有点麻烦</p>
</li>
<li>
<p>&quot;Bitmap too large to be uploaded into a texture&quot;<br>
解决方案，重新设置 bitmap 大小，OpenGL limit 是 2048 * 2048</p>
</li>
<li>
<p><code>kitkat</code>之前<code>listview</code>的<code>addHeaderView()</code>需要在setAdapter之前调用，<br>
<code>kitkat</code>之后<code>addHeaderView()</code>可以在前后调用</p>
</li>
<li>
<p><code>RecyclerView</code> 23.1.1 版有 bug，解决方案，重写 <code>LineaLayoutManager</code> 的 <code>onLayoutChildren</code></p>
<pre><code>@Override
public void onLayoutChildren(RecyclerView.Recycler recycler,    RecyclerView.State state) {
try {
    super.onLayoutChildren(recycler, state);
} catch (IndexOutOfBoundsException e) {
    Log.e(&quot;probe&quot;, &quot;meet a IOOBE in RecyclerView&quot;);
}
</code></pre>
<p>}</p>
<p><code>java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder</code></p>
<p>http://stackoverflow.com/questions/31759171/recyclerview-and-java-lang-indexoutofboundsexception-inconsistency-detected-in</p>
</li>
<li>
<p>Fresco 停止恢复加载<br>
<code>Fresco.getImagePipeline().resume();</code><br>
<code>Fresco.getImagePipeline().paused();</code></p>
</li>
<li>
<p>不知道为什么的bug，记录，子布局 marginBottom 没作用，父级布局中 paddingBottom 可以用</p>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/item_tc_home_root_cv&quot;
    android:layout_marginBottom=&quot;16dp&quot;
    app:cardBackgroundColor=&quot;@color/color_white&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot; &gt;
    &lt;LinearLayout
    android:orientation=&quot;vertical&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;
        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;200dp&quot;/&gt;
        &lt;RelativeLayout
            android:paddingBottom=&quot;16dp&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#ffffff&quot;&gt;
            &lt;LinearLayout
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_marginLeft=&quot;50dp&quot;
                android:layout_marginTop=&quot;10dp&quot;
                android:id=&quot;@+id/linear_one&quot;
                android:orientation=&quot;vertical&quot;&gt;
                &lt;com.facebook.drawee.view.SimpleDraweeView
                    app:placeholderImage=&quot;@mipmap/icon_head_image&quot;
                    app:roundAsCircle=&quot;true&quot;
                    android:layout_width=&quot;60dp&quot;
                    android:layout_height=&quot;60dp&quot;
                    android:src=&quot;@mipmap/icon_head_image&quot;
                    android:id=&quot;@+id/avatar_iv&quot; /&gt;
            &lt;/LinearLayout&gt;
            &lt;LinearLayout
                android:layout_width=&quot;200dp&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:layout_alignParentRight=&quot;true&quot;
                android:orientation=&quot;horizontal&quot;
                android:layout_marginTop=&quot;16dp&quot;
                android:layout_marginRight=&quot;16dp&quot;
                android:id=&quot;@+id/linear_two&quot;
                android:weightSum=&quot;3&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;0dp&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_weight=&quot;1&quot;
                    android:textSize=&quot;16sp&quot;
                    android:textColor=&quot;#ff467d&quot;
                    android:id=&quot;@+id/post_count_tv&quot;
                    android:text=&quot;45&quot;
                    android:gravity=&quot;center&quot;/&gt;
                &lt;TextView
                    android:layout_width=&quot;0dp&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_weight=&quot;1&quot;
                    android:textSize=&quot;16sp&quot;
                    android:textColor=&quot;#ff467d&quot;
                    android:id=&quot;@+id/fans_count_tv&quot;
                    android:text=&quot;2322&quot;
                    android:gravity=&quot;center&quot;/&gt;
                &lt;TextView
                    android:layout_width=&quot;0dp&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_weight=&quot;1&quot;
                    android:textSize=&quot;16sp&quot;
                    android:textColor=&quot;#ff467d&quot;
                    android:id=&quot;@+id/follow_count_tv&quot;
                    android:text=&quot;172&quot;
                    android:gravity=&quot;center&quot;/&gt;
            &lt;/LinearLayout&gt;
            &lt;LinearLayout
                android:layout_width=&quot;200dp&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:orientation=&quot;horizontal&quot;
                android:layout_alignParentRight=&quot;true&quot;
                android:layout_below=&quot;@+id/linear_two&quot;
                android:layout_marginTop=&quot;16dp&quot;
                android:layout_marginRight=&quot;16dp&quot;
                android:id=&quot;@+id/linear_three&quot;
                android:weightSum=&quot;3&quot;
                &gt;
        &lt;TextView
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_weight=&quot;1&quot;
            android:textColor=&quot;#999999&quot;
            android:textSize=&quot;12sp&quot;
            android:text=&quot;帖子&quot;
            android:gravity=&quot;center&quot;/&gt;
        &lt;TextView
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_weight=&quot;1&quot;
            android:textColor=&quot;#999999&quot;
            android:textSize=&quot;12sp&quot;
            android:text=&quot;粉丝&quot;
            android:gravity=&quot;center&quot;/&gt;
        &lt;TextView
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_weight=&quot;1&quot;
            android:textColor=&quot;#999999&quot;
            android:textSize=&quot;12sp&quot;
            android:text=&quot;关注&quot;
            android:gravity=&quot;center&quot;/&gt;
    &lt;/LinearLayout&gt;
    &lt;TextView
        android:layout_marginLeft=&quot;48dp&quot;
        android:layout_below=&quot;@+id/linear_one&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:singleLine=&quot;true&quot;
        android:textSize=&quot;18sp&quot;
        android:gravity=&quot;center&quot;
        android:id=&quot;@+id/oldDriver_name_tv&quot;
        android:textColor=&quot;#4c4c4c&quot;
        android:text=&quot;大哥&quot;/&gt;
    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@+id/oldDriver_name_tv&quot;
        android:layout_marginLeft=&quot;16dp&quot;
        android:layout_marginRight=&quot;16dp&quot;
        android:text=&quot;cos 爱好者、我的博客地址：http:www.....&quot;
        android:textColor=&quot;#999999&quot;
        android:textSize=&quot;14sp&quot;
        android:id=&quot;@+id/personal_description_tv&quot;
        android:layout_marginTop=&quot;16dp&quot; /&gt;
    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@+id/personal_description_tv&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:gravity=&quot;center&quot;&gt;
        &lt;ImageView
            android:layout_width=&quot;114dp&quot;
            android:layout_height=&quot;48dp&quot;
            android:src=&quot;@mipmap/follow&quot;
            android:id=&quot;@+id/follow_iv&quot;/&gt;
    &lt;/LinearLayout&gt;

&lt;/RelativeLayout&gt;
</code></pre>
</li>
<li>
<p><code>ICCP: Not recognizing known sRGB profile that has been edited</code> 错误，好像是<code>png</code>是<code>sRGB</code>导致的错误，解决方案在<code>buildToolsVersion</code>下面加：</p>
<pre><code>aaptOptions.cruncherEnabled = false
aaptOptions.useNewCruncher = false
</code></pre>
</li>
</ol>
<p>可以取消<code>Android Studio</code>对图片合法性的检查(参考：http://my.oschina.net/1pei/blog/479162)</p>
<ol>
<li>debug.keystore 问题（不同可以跑不同apk，不过大部分apk会有验证，回到导致APP运行失败）</li>
<li>隐式调用在5.0后不允许，两种方案：</li>
</ol>
<ul>
<li>该成显式调用</li>
</ul>
<pre><code>    Intent serviceIntent = new Intent(context,MyService.class);
    context.startService(serviceIntent);
</code></pre>
<ul>
<li>加上包名</li>
</ul>
<pre><code>        PackageManager pm = context.getPackageManager();
        List&lt;ResolveInfo&gt; resolveInfoList = pm.queryIntentServices(implicitIntent, 0);
        if (resolveInfoList == null || resolveInfoList.size() != 1) {
            return null;
        }
        ResolveInfo serviceInfo = resolveInfoList.get(0);
        ComponentName component = new ComponentName(serviceInfo.serviceInfo.packageName, serviceInfo.serviceInfo.name);
        Intent explicitIntent = new Intent(implicitIntent);
        explicitIntent.setComponent(component);
</code></pre>
<ol>
<li>service 需要先unbind（如果bind过的话），不然无法stopService</li>
<li>ExecutorService 的 execute 和 submit 方法，前者会往外部抛出错误，后者不会。参考<a href="https://segmentfault.com/a/1190000000669942">ExecutorService的坑</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【旧】引用传递和值传递(pass by value vs pass by reference)]]></title>
        <id>https://flyer88.github.io/post/jiu-yin-yong-chuan-di-he-zhi-chuan-di-pass-by-value-vs-pass-by-reference/</id>
        <link href="https://flyer88.github.io/post/jiu-yin-yong-chuan-di-he-zhi-chuan-di-pass-by-value-vs-pass-by-reference/">
        </link>
        <updated>2020-06-15T09:44:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>写于 2016 年 07 月 30 日</p>
</blockquote>
<ul>
<li>一. 值类型和引用类型（此处先不考虑String）的传递</li>
<li>二. String的问题：
<ul>
<li>
<ol>
<li>String问题来源</li>
</ol>
</li>
<li>2.脑洞猜想可能情况</li>
<li>3.字节码验证</li>
<li>4.最终结论</li>
</ul>
</li>
</ul>
<p>写这个的原因主要是今天看到了<a href="https://www.zhihu.com/question/31203609">知乎的一个问题</a>，发现自己有些地方有点懵逼，写下来记录一下，<a href="http://zhihu.com/question/31203609/answer/50992895">知乎上排名第一的答案</a>说的很清楚，不过看了以后依旧有点迷迷糊糊，所以自己写了个几行代码测试。</p>
<p>首先上一个，感觉比较对的结论：</p>
<p><strong>Horstmann的《java核心技术》（中文第8版P115-P117）原文描述：</strong></p>
<p><strong>”java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。“</strong></p>
<p><strong>”有些程序员（甚至是本书的作者），认为java程序设计语言对对象采用的是引用调用，实际上这种理解是不对的。”</strong></p>
<p>然后补充几句我的理解：</p>
<ol>
<li>首先，Java在传递过程中，传递的只有值，但是表现出来的形式，却既有值传递也有引用传递，因此，没必要纠结于名字，能理解原理即可。</li>
<li>在传递对象进函数时，对象的所有数据会被拷贝到局部变量中，这也就导致了局部变量修改其成员变量值时会导致原始的变量的成员变量值产生响应的改变，因为他们持有的成员变量的引用指向了同一个地址块(内存空间)。</li>
<li>而对于传递8种基本变量时，也只是拷贝了值，因此对基本变量其本身的修改，无法导致原始变量的的修改。</li>
<li>不过这里需要考虑特殊情况，就是String，其表现形式和8种基本变量一样，具体下文有分析，而对于String为何要这么做，我也不清楚，不是很懂 jvm 和 Java 的设计。</li>
</ol>
<hr>
<hr>
<h2 id="一-值类型和引用类型此处先不考虑string的传递">一. 值类型和引用类型（此处先不考虑String）的传递：</h2>
<pre><code>public class Student {
    int age;
    String name;
}
public class TestReference {
    public static void main(String[] args){
        Student student = new Student();
        student.age = 10;
        System.out.println(student.age);//10
        addAge(student);
        System.out.println(student.age);//11
        addAge(student.age);
        System.out.println(student.age);//11
    }

    static public void addAge(Student paramStudent){
        paramStudent.age = 11;
    }

    static public void addAge(int paramAge){
        paramAge = 12;
    }
}
</code></pre>
<p>对以上代码进行解释</p>
<ul>
<li>首先<code>addAge(student)</code>调用的是<code>addAge(Student paramStudent)</code>，该部分其实很好理解，首先，<code>paramStudet</code>对象，拷贝了传入的<code>studet</code>对象所有的数据，因此<code>paramStudet</code>它所指向的地址，其实和<code>student</code>是一样的，所以，当<code>paramStudent</code>改变它的<code>age</code>值时，其触发的操作和<code>student</code>改变<code>age</code>的值是一样的 ,因为他们都指向了同一个地址块。</li>
<li>其次<code>addAge(student.age)</code>调用的是<code>addAge(int paramAge)</code>，也很好理解，<code>paramAge</code>也只是拷贝了<code>studet.age</code>的值，此处为10，然后改变了<code>paramAge</code>的值，但此时<code>paramAge</code>与引用类型不同，它保存的只有一个值，所以其实这个<code>parmaAge</code>作为一个局部变量，并不能对原本的<code>student.age</code>产生任何影响</li>
</ul>
<h2 id="二-string的问题">二. String的问题：</h2>
<h3 id="1-string问题来源">1. String问题来源</h3>
<p>上面的例子其实很好搞清楚，但是我在碰到String的时候就有点懵逼了,如果调用以下方法，结果会如注释显示。</p>
<pre><code>public static void main(String[] args){
    Student student = new Student();
    student.age = 10;
    student.name = &quot;dove&quot;;
    changeName(student);
    System.out.println(student.name);//dove_2
    changeName(student.name);
    System.out.println(student.name);//dove_2
    changeName2(student.name); 
    System.out.println(student.name);//dove_2         
}      
static void changeName(Student paramStudent){
    paramStudent.name = &quot;dove_2&quot;;
}
static void changeName(String paramName){
    paramName = &quot;dove_3&quot;;
}
static void changeName2(String paramName){
    paramName += &quot;233&quot;;
}
</code></pre>
<p><code>changeName2(String paramName)</code>此处讲道理被调用后应该是&quot;dove_2233&quot;,因为<code>String</code>是一个引用类型,也就是说此处的<code>parmaName</code>应该是指向和传入的参数指向了相同的一个地址块，然后对指向的内存进行了修改,然而结果并不是,原因就在于<code>String</code>是一个不可变的类型(为啥不可变呢,具体可以看<code>String</code>类的实现,它是一个<code>final class</code>,并且其内部正真保存着字符串的<code>value[]</code>也是不可变的(<code>final</code>)，所以意味着修改<code>Sting</code>是不可能的)。</p>
<h3 id="2脑洞猜想可能情况">2.脑洞猜想可能情况</h3>
<p>所以猜测上述的<code>changeName2</code>过程类似于</p>
<pre><code>    FuckString fuckString = new FuckString();//paramName
    FuckString fuckString2 = new FuckString(fuckString);//构造出的新的值
    fuckString = fuckString2;//把paramName指向构造出的新值
</code></pre>
<p>然后，这就有点想不通了，不可变的类型，String 的 <code>+</code> 是怎么弄的呢？打个断点试试看，强制进入，发现跳转到了StringBuilder的构造方法里，这说明应该是构造了一个新的StringBuilder对象。</p>
<figure data-type="image" tabindex="1"><img src="http://www.dove.farbox.com/java/_image/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/19-58-14.jpg" alt="img" loading="lazy"></figure>
<p>同时，底部的Debug里抛出了个错误，说是无法获取<code>StringBuilder.toString()</code>,也就进一步证明此处有新的<code>String</code>的产生。</p>
<figure data-type="image" tabindex="2"><img src="http://www.dove.farbox.com/java/_image/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/19-58-59.jpg" alt="img" loading="lazy"></figure>
<p>到这里基本上就验证了我的猜想，<code>String</code> <code>+</code>会产生一个新的<code>String</code>对象，既然这样，反编译下，看下字节码，估计基本就搞定这个懵逼的问题了。</p>
<h3 id="3字节码验证">3.字节码验证</h3>
<p>于是就写了以下的类，用来验证：</p>
<pre><code>public class Main {
    public static void main(String[] args){
        String s = &quot;dove&quot;;
        s += &quot;233&quot;;
    }
}
</code></pre>
<p>然后javac，然后javap -c，看字节码,如下图。</p>
<figure data-type="image" tabindex="3"><img src="http://www.dove.farbox.com/java/_image/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/20-03-38.png" alt="img" loading="lazy"></figure>
<p>尝试着解释下该部分代码（不是很看的懂字节码，所以有些解释可能不是很规范，不过讲道理大概意思不会差很远)</p>
<ul>
<li><code>String s = &quot;dove&quot;;</code>部分字节码及解释</li>
</ul>
<pre><code>       0: ldc           #2                  // String dove
       2: astore_1
</code></pre>
<p>第0行，将一个常量加载到操作数栈,也就是把“dove”这玩意，放进了操作数栈(也不知道是什么东西，蛤蛤)</p>
<p>第2行，将一号数值（下划线1代表一号，大概理解，不是很准确）从操作数栈存储到局部变量表，说白了就是把“dove”给存了起来？</p>
<ul>
<li><code>s += &quot;233&quot;;</code>部分字节码及解释</li>
</ul>
<pre><code>       3: new           #3                  // class java/lang/StringBuilder
       6: dup
       7: invokespecial #4                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V
      10: aload_1    
      11: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      14: ldc           #6                  // String 233
      16: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      19: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
</code></pre>
<p>第3行，这个很明显，不google也知道，<code>new StringBuilder()</code>，也就是搞了个<code>StringBUilder</code>的实例。</p>
<p>第6行，Java虚拟机提供了一些用于直接操作操作数栈，不是很懂，貌似对整体理解影响不大，先过。</p>
<p>第7行，invokespecial 调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法，此处应该是在初始化StringBuilder对象。</p>
<p>第10行，将1号局部变量(下划线1指代一号变量)加载到操作栈，这里应该是指“dove”</p>
<p>第11行，调用对象的实例方法,此处就是调用<code>StringBuilder.append</code>,也就是把“dove”加到了<code>StringBuilder</code>中</p>
<p>第14行，将一个常量加载到操作数栈，就是把“233”载入</p>
<p>第16行，调用对象的实例方法,此处就是调用<code>StringBuilder.append</code>，把“233”给加到“StringBuilder”中</p>
<p>第19行，调用对象的实例方法,此处就是调用<code>StringBuilder.toString</code>，而该方法，会触发<code>new String()</code>的操作，因此，会返还一个新的<code>String</code>对象</p>
<h3 id="4最终结论">4.最终结论：</h3>
<p>从脑洞断点以及最后的字节码分析可以看出，<code>s +=&quot;233&quot;</code>,会导致一个新的String对象生成，也就是说，调用<code>changeName2(String paramName)</code>会使得<code>paramName</code>指向一个新的String对象，这样就意味着，对该数据的改变并不会影响本身<code>student.name</code>的值,由此，String懵逼的问题也解决了。</p>
<hr>
<hr>
<p>以上，就是整个关于Java引用传递和值传递的理解，有说的不对的，望指正。</p>
]]></content>
    </entry>
</feed>