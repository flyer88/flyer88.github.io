<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flyer</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dove.im/"/>
  <updated>2016-11-23T05:33:21.000Z</updated>
  <id>http://dove.im/</id>
  
  <author>
    <name>flyer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dagger2 学习(三)- scope 使用</title>
    <link href="http://dove.im/2016/11/21/dagger2-%E5%AD%A6%E4%B9%A0-%E4%B8%89-scope-%E4%BD%BF%E7%94%A8/"/>
    <id>http://dove.im/2016/11/21/dagger2-学习-三-scope-使用/</id>
    <published>2016-11-21T07:56:30.000Z</published>
    <updated>2016-11-23T05:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Scope">关于<code>Scope</code></h2><p>Dagger 2 自带的 <code>Scope</code> 只有一个 <code>@Singleton</code> ，其他的可以通过自定义来实现</p>
<p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A03Scope-%E4%BD%BF%E7%94%A8" target="_blank" rel="external">本文代码</a></p>
<h3 id="1-_前言">1. 前言</h3><h4 id="(1)_Scope_的作用，就是提供在当前_Component_实例_范围内的单例。">(1)  <code>Scope</code> 的作用，就是提供在当前 <code>Component</code> 实例 范围内的单例。</h4><p>假设 DaggerUserComponent 能够提供 User 实例</p>
<p>UserComponent 被自定义的  <code>@UserScope</code> 标注，那就意味着</p>
<p>一旦一个 DaggerUserComponent 实例创建完成，</p>
<p>那么其调用 injectTo 方法，进行注入时，所有注入的 <code>User</code> 对象都是同一个实例</p>
<p>知道 DaggerUserComponent 被重新创建，才会提供一个不一样的<code>User</code>实例</p>
<h4 id="(2)_@Scope_的使用方法">(2) <code>@Scope</code> 的使用方法</h4><p> 第一种</p>
<ol>
<li><code>@Scope</code> 注解整个 <code>Bean</code> 对象，<code>@inject</code> 注解对应 <code>Bean</code> 对象的构造方法</li>
<li><code>@Scope</code> 还需要在 <code>Bean</code> 对象注入，出现的 <code>Component</code> 中标注</li>
</ol>
<p>第二种</p>
<ol>
<li><code>@Scope</code> 配合 在<code>Module</code> 中使用，配合 <code>@Provides</code> 一起标注</li>
<li><code>@Scope</code> 需要在 <code>Module</code> 出现的 <code>Component</code> 中标注</li>
</ol>
<p>两种方法，其实就是两种提供实例的不同实现，对比前面 一二两篇文章即可看出</p>
<p>第一种是最简单注入时，加上<code>@Scope</code> </p>
<p>第二种是配合<code>@Module</code> 注入式，加上<code>@Scope</code></p>
<hr>
<h3 id="2-_进行实践操作">2. 进行实践操作</h3><h4 id="(1)_整体结构构建">(1) 整体结构构建</h4><p>实践的内容主要是针对 <code>@Scope</code> 第二种使用方法</p>
<p>因此这中间<code>@UserScope</code> 只需要添加到 <code>UserModule</code> 和 <code>UserComponent</code> 上</p>
<p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A03Scope-%E4%BD%BF%E7%94%A8" target="_blank" rel="external">具体代码</a></p>
<p>整个类的结构</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/代码结构.png" alt="代码结构"></p>
<p>创建三个 <code>Activity</code> 分别用于显示 <code>User</code> 实例</p>
<p>下面贴出部分代码</p>
<p>自定义  <code>UserScope.java</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Scope</span></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> UserScope &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>User.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	...<span class="comment">//纯 Bean 对象,无任何特殊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserComponent.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@UserScope</span><span class="comment">// 绑定 UserScope</span></span><br><span class="line"><span class="annotation">@Component</span>(modules = &#123;UserModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectTo</span><span class="params">(ClassARoomActivity classARoomActivity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectTo</span><span class="params">(ClassBRoomActivity classBRoomActivity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserModule.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModule</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="annotation">@UserScope</span><span class="comment">// 绑定 UserScope</span></span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function">User <span class="title">provideUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>App.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> UserComponent sUserComponent;</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserComponent <span class="title">getUserComponent</span><span class="params">()</span></span>&#123;<span class="comment">// 获取 DaggerUserComponent 对象</span></span><br><span class="line">       <span class="keyword">if</span> (sUserComponent == <span class="keyword">null</span>)&#123;</span><br><span class="line">           sUserComponent = DaggerUserComponent.builder().userModule(<span class="keyword">new</span> UserModule())</span><br><span class="line">                   .build();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sUserComponent;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseUserComponent</span><span class="params">()</span></span>&#123; <span class="comment">// 清空 DaggerUserComponent 对象</span></span><br><span class="line">       sUserComponent = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<h4 id="(2)_具体生成代码和调用分析">(2) 具体生成代码和调用分析</h4><h5 id="a-_代码生成部分分析">a. 代码生成部分分析</h5><p><code>DaggerUserComponent.java</code> 部分代码变化</p>
<p>未加上 <code>@UserScope</code> 时，<code>provideUserProvider</code> 的生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.provideUserProvider = UserModule_ProvideUserFactory.create(builder.userModule);</span><br></pre></td></tr></table></figure>
<p>加上 <code>@UserScope</code> 后，<code>provideUserProvider</code> 的生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.provideUserProvider =</span><br><span class="line">    DoubleCheck.provider(UserModule_ProvideUserFactory.create(builder.userModule));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，虽然此处的 <code>provideUserProvider</code> 依然是 <code>Provider&lt;User&gt;</code> </p>
<p>但是，其实它的实例已经是 <code>DoubleCheck&lt;User&gt;</code> 类型的。</p>
</blockquote>
<p>跟进这个<code>DoubleCheck.provider()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Provider&lt;T&gt; <span class="title">provider</span><span class="params">(Provider&lt;T&gt; delegate)</span> </span>&#123;</span><br><span class="line">   checkNotNull(delegate);</span><br><span class="line">   <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> DoubleCheck) &#123;</span><br><span class="line"><span class="comment">// 如果是 DoubleCheck 的实例，直接返回</span></span><br><span class="line">     <span class="keyword">return</span> delegate;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 否则创建一个，此处的 delegate 就是 UserModule_ProvideUserFactory.create(builder.userModule)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DoubleCheck&lt;T&gt;(delegate);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>跟进构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">(Provider&lt;T&gt; provider)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> provider != <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.provider = provider;</span><br><span class="line">  <span class="comment">// 啥都没有，就是赋值了一个 provider 引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以综上，可以判断出，和之前的没有<code>@UserScope</code> 注解对比，具体的实例提供者改变了，不是生成<code>UserModule_ProvideUserFactory</code> 对象了，变成了<code>DoubleCheck&lt;User&gt;</code> 对象，其内部持有一个 <code>UserModule_ProvideUserFactory</code> 的引用。</p>
<h5 id="b-整体调用链">b.整体调用链</h5><p> <code>DaggerUserComponent.injectTo</code> -&gt; <code>ClassARoomActivity_MembersInjector.injectMembers()</code> -&gt; <code>mUserProvider.get()</code> -&gt; <code>DoubleCheck&lt;User&gt;.get()</code></p>
<p>下面进行具体分析</p>
<ul>
<li><p><code>DaggerUserComponent.injectTo</code> -&gt; <code>ClassARoomActivity_MembersInjector.injectMembers()</code> 部分</p>
<p>因此其调用的实例也有了对应的改变，对应的<code>xxxInjector.java</code> 的<code>injectMemebers</code> 方法在调用时，会调用不同的实例</p>
<p>该部分代码和之前并无区别，主要是运行时，实例的区别    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectTo</span><span class="params">(ClassARoomActivity classARoomActivity)</span> </span>&#123;</span><br><span class="line">  classARoomActivityMembersInjector.injectMembers(classARoomActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(ClassARoomActivity instance)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  instance.mUser = mUserProvider.get();<span class="comment">// 注意该部分会调用不同的实例对应的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mUserProvider.get()</code> -&gt; <code>DoubleCheck&lt;User&gt;.get()</code></p>
<p> 未加上<code>@UserScop</code> 时，实例是 <code>UserModule_ProvideUserFactory</code></p>
<p>调用的是<code>UserModule_ProvideUserFactory.java</code> 中的方法，如下</p>
</li>
</ul>
<pre><code><span class="comment"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Preconditions.checkNotNull(</span><br><span class="line">    module.provideUser(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>

 加上`@UserScop` 时，实例是`DoubleCheck<span class="tag">&lt;<span class="title">User</span>&gt;</span>`

调用的是 `DoubleCheck<span class="tag">&lt;<span class="title">T</span>&gt;</span>` 中的方法，如下，该部分也是实现 `Scope` 功能重要的一部分


<span class="comment"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">         <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Object result = instance;</span><br><span class="line">           <span class="keyword">if</span> (result == UNINITIALIZED) &#123;<span class="comment">// 如果该对象从来没有初始化，那就初始化一次</span></span><br><span class="line">             <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               result = instance;<span class="comment">// 获取最新实例，防止线程之间同时修改</span></span><br><span class="line">               <span class="keyword">if</span> (result == UNINITIALIZED) &#123;</span><br><span class="line">                 result = provider.get();<span class="comment">// 此处依旧调用了 UserModule_ProvideUserFactory.get() 方法</span></span><br><span class="line">                 Object currentInstance = instance;</span><br><span class="line">                 <span class="keyword">if</span> (currentInstance != UNINITIALIZED &amp;&amp; currentInstance != result) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Scoped provider was invoked recursively returning "</span></span><br><span class="line">+ <span class="string">"different results: "</span> + currentInstance + <span class="string">" &amp; "</span> + result);</span><br><span class="line">           &#125;</span><br><span class="line">      instance = result;</span><br><span class="line">      <span class="comment">// 赋值最新的值</span></span><br><span class="line">      provider = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 初始化一次以后，该对象对应的 Provider 在当前 Scope 中其实已经没有意义了，</span></span><br><span class="line">      <span class="comment">// 所以直接置为空，方便 GC 回收</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) result;<span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><blockquote>
<blockquote>
<p>注意，Provider 的置空</p>
<p>此处的置空不会影响数据的获取，该 <code>provider</code> 的引用就是下面方法中的 <code>UserModule_ProvideUserFactory.create(builder.userModule)</code> 对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="keyword">this</span>.provideUserProvider =  DoubleCheck.provider(UserModule_ProvideUserFactory.create(builder.userModule));</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<hr>
<h3 id="3-_总结">3. 总结</h3><p>总结：</p>
<p><code>@UserScope</code> 作用于 <code>Component</code> 生命周期内</p>
<p>限制了被标注的实例提供者，只会实例化该对象一次，之后会抛弃对应的 <code>Provider</code> ，然后永远获取之前创建的<code>User</code></p>
<blockquote>
<p> <code>@UserScope @Provides provideUser()</code> ==&gt; <code>UserModule_ProviderUserFactory</code></p>
<p> 此处抛弃的就是 <code>UserModule_ProviderUserFactory</code> 的实例</p>
</blockquote>
<p>只有当实例化的 <code>Component</code> 对象被重新构建，被标注的实例提供者才会重新创建</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/Dagger2%20%E5%AD%A6%E4%B9%A0%28%E4%B8%89%29.png" alt="Dagger2 学习(三)"></p>
<blockquote>
<p>一家之言，仅供参考</p>
<p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A03Scope-%E4%BD%BF%E7%94%A8" target="_blank" rel="external">本文代码</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于Scope&quot;&gt;关于&lt;code&gt;Scope&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;Dagger 2 自带的 &lt;code&gt;Scope&lt;/code&gt; 只有一个 &lt;code&gt;@Singleton&lt;/code&gt; ，其他的可以通过自定义来实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[旧] LayoutInflater 源码流程记录</title>
    <link href="http://dove.im/2016/11/19/%E6%97%A7-LayoutInflater-%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <id>http://dove.im/2016/11/19/旧-LayoutInflater-源码流程记录/</id>
    <published>2016-11-19T06:30:12.000Z</published>
    <updated>2016-11-19T06:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>走了一遍 LayoutInflater的流程，特此记录</p>
<h3 id="获取_LayoutInflater_—-_LayoutInflater-from(context)">获取 LayoutInflater —- <code>LayoutInflater.from(context)</code></h3><p>获取LayoutInflater对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取 layoutInflater，注意这是一个IPC的过程，获取的实例是PhoneLayoutInflater，与LayoutInflater 区别不大，重写了protected View onCreateView(String name, AttributeSet attrs) 函数，具体可以去看源码，位置是frameworks/base/core/java.com.android.internal.policy.impl</span></span><br><span class="line">            LayoutInflater LayoutInflater =</span><br><span class="line">                    (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        <span class="comment">//如果为空抛出错误       </span></span><br><span class="line">            <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">                    <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用Inflate_—_LayoutInflater-from(context)-inflate(R-layout-activity_layout,null,false)">调用Inflate — <code>LayoutInflater.from(context).inflate(R.layout.activity_layout,null,false)</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取resource对象</span></span><br><span class="line">       <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//把R.layout.activity_layout 放入，获取整个 Xml的Parser</span></span><br><span class="line">       <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 开始真正的inflate</span></span><br><span class="line">           <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           parser.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="inflate(XmlPullParser_parser,_ViewGroup_root,_boolean_attachToRoot)是整个inflate的核心部分"><code>inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</code>是整个<code>inflate</code>的核心部分</h3><p>整体流程：<br>找到最外层的父级布局 ===》 处理<code>merge</code>节点情况 ===》实例化父级布局 ===》根据父级布局，调用<code>rInflate</code>函数去实例化子级<code>view</code> ===&gt; 根据实例化结果，以及外部参数，进行<code>view</code>的添加以及结果的返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步进入</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</span><br><span class="line">        <span class="comment">// 解析返回 attrs</span></span><br><span class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        Context lastContext = (Context)mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = mContext;</span><br><span class="line">        <span class="comment">// 传入的 viewgroup 是 null</span></span><br><span class="line">        View result = root;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此处尝试寻找开始和结束节点，即找到整个layout的最外层 view</span></span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 type != 开始节点抛出错误，也就是说没找到开始节点</span></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</span><br><span class="line">                        * <span class="string">": No start tag found!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前节点的名字，也就是当前layout的根节点的名字</span></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//处理 merge 节点</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                            * <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rInflate(parser, root, attrs, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 不是merge的情况下</span></span><br><span class="line">                <span class="comment">// createViewFromTag 该方法是根据前面获取的 tag 的名字，创建具体的view对象</span></span><br><span class="line">                <span class="comment">// 此处特殊的地方时，Temp 就是根节点，也就是整个layout的根节点，因为 name 是前面获取的根节点的名字</span></span><br><span class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, attrs, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 初始化 params</span></span><br><span class="line">                ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;<span class="comment">// root != 空，会初始化出一个 params</span></span><br><span class="line">                    </span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 如果提供了root，会根据 root 创建 layout params </span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// Set the layout params for temp if we are not</span></span><br><span class="line">                        <span class="comment">// attaching. (If we are, we use addView, below)</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 此处，会进行所有的 temp 的子 view 的 inflate</span></span><br><span class="line">                rInflate(parser, temp, attrs, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// We are supposed to attach all the views we found (int temp)</span></span><br><span class="line">                <span class="comment">// to root. Do that now.</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Decide whether to return the root that was passed in or the</span></span><br><span class="line">                <span class="comment">// top view found in xml.</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Don't retain static reference on context.</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中整个流程中，核心部分分两点<br>1.实例化父级布局，<br>2.实例化子级<code>view</code>。<br>而对于<code>merge</code>节点的处理情况是将其当做子<code>view</code>进行处理，调用的都是<code>rInflate</code>函数，所以，我们讨论子<code>view</code>实例化的时候可以一起讨论。</p>
<h4 id="首先是看第一部分，父布局temp的实例化。">首先是看第一部分，父布局<code>temp</code>的实例化。</h4><p>他是直接调用<code>createViewFromTag</code>，我们进入该函数。这个函数整体的流程是<br>处理特殊节点<code>view</code> ===》 对当前<code>view</code>的context进行初始化 ====》 特殊节点<code>blink</code>处理 ===》根据几个工厂对象(默认情况下，工程类都为null)实例化<code>view</code> ===》 工厂类创建失败，<code>view == null</code>，调用<code>onCreateView()</code>或者<code>createView()</code>对<code>view</code>进行实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, AttributeSet attrs, <span class="keyword">boolean</span> inheritContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特殊处理 `view` 节点</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前 view 的 context</span></span><br><span class="line">    Context viewContext;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span> &amp;&amp; inheritContext) &#123;</span><br><span class="line">        <span class="comment">// 如果父级 view 不为空 并且要求从父级 view 那里获取 context</span></span><br><span class="line">        viewContext = parent.getContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则 当前 view 的 context 等于 LayoutInflater.fromt(context) 中传入的 context</span></span><br><span class="line">        viewContext = mContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有主题切换，那么就应用对应的主题</span></span><br><span class="line">    <span class="keyword">final</span> TypedArray ta = viewContext.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">        viewContext = <span class="keyword">new</span> ContextThemeWrapper(viewContext, themeResId);</span><br><span class="line">    &#125;</span><br><span class="line">    ta.recycle();</span><br><span class="line">    <span class="comment">// blink 处理</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">        <span class="comment">// Let's party like it's 1995!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlinkLayout(viewContext, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用工厂类创建真正的 view 对象</span></span><br><span class="line">        <span class="comment">// 默认两个工厂类都为 null</span></span><br><span class="line">        <span class="comment">// 所以 view 是 null</span></span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, viewContext, attrs);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(mFactory != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">            view = mFactory.onCreateView(name, viewContext, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在 view 用前面两个工厂类创建为 null </span></span><br><span class="line">        <span class="comment">// 同时私有工厂类不为空的情况下，调用私有的工厂类创建 view 对象</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, viewContext, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 私有工厂创建依旧为 null 时</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = viewContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;<span class="comment">// 如果是 Android 自带 view</span></span><br><span class="line">                    view = onCreateView(parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是 Android 自带 view</span></span><br><span class="line">                    view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中这个函数的核心部分则是<code>onCreateView()</code>和<code>createView()</code>，因为默认情况下，几个factory都是null，所以都会进入这两个函数中的一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;<span class="comment">// 如果是 Android 自带 view</span></span><br><span class="line">    view = onCreateView(parent, name, attrs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是 Android 自带 view</span></span><br><span class="line">    view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个函数调用条件是，<code>-1 == name.indexOf(&#39;.&#39;)</code>，而其效果则是，判断是否为<code>Android</code>自带 <code>view</code>，如果是，则调用<code>onCreateView()</code>,否则当做自定义<code>view</code>处理，调用<code>createView()</code></p>
<p>先看<code>onCreateView</code>，该部分主要是对<code>sClassPrefixList</code>进行迭代，拼凑出整个<code>view</code>的路径，然后调用<code>createView()</code>，注意这个函数，和上面说的处理自定义<code>view</code>的<code>createView()</code>，是同一个函数，所以也就明白，为什么要有上面的判断了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sClassPrefixList = &#123;</span><br><span class="line">    <span class="string">"android.widget."</span>,</span><br><span class="line">    <span class="string">"android.webkit."</span>,</span><br><span class="line">    <span class="string">"android.app."</span></span><br><span class="line">&#125;;</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"> <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            View view = createView(name, prefix, attrs);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看真正的动态创建出<code>view</code>对象的函数<code>createView(String name, String prefix, AttributeSet attrs)</code>，该函数的作用就是，通过反射创建出真正的对象<br>其过程也很简单，直接在已经存在的<code>sConstructorMap</code>中找，是不是有这个名字，如果有就开始创建，没有就把前缀拼上去，再创建，然后放入<code>sConstructorMap</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line">        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">        Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line">            <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Class not found in the cache, see if it's real, and try to add it</span></span><br><span class="line">                clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                        prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (mFilter != <span class="keyword">null</span> &amp;&amp; clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                    <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">                sConstructorMap.put(name, constructor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If we have a filter, apply it to cached constructor</span></span><br><span class="line">                <span class="keyword">if</span> (mFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Have we seen this name before?</span></span><br><span class="line">                    Boolean allowedState = mFilterMap.get(name);</span><br><span class="line">                    <span class="keyword">if</span> (allowedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// New class -- remember whether it is allowed</span></span><br><span class="line">                        clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                                prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">boolean</span> allowed = clazz != <span class="keyword">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class="line">                        mFilterMap.put(name, allowed);</span><br><span class="line">                        <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                            failNotAllowed(name, prefix, attrs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(allowedState.equals(Boolean.FALSE)</span>) </span>&#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Object[] args = mConstructorArgs;</span><br><span class="line">            args[<span class="number">1</span>] = attrs;</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">final</span> View view = constructor.newInstance(args);</span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</span><br><span class="line">                <span class="comment">// Use the same context when inflating ViewStub later.</span></span><br><span class="line">                <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class="line">                viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="然后是子布局的实例化">然后是子布局的实例化</h4><p>该部分内容，主要是对当前节点的所有view 进行遍历，然后调用<code>createViewFromTag()</code>(该方法上面已经有解释了)方法创建实例。如果遍历到某一个view，他是有子节点的，则递归调用函数<code>rInflate()</code>对该子节点进行遍历。该部分参考下面的流程图，看起来更加清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, <span class="keyword">final</span> AttributeSet attrs,</span><br><span class="line">        <span class="keyword">boolean</span> finishInflate, <span class="keyword">boolean</span> inheritContext)</span> <span class="keyword">throws</span> XmlPullParserException,</span><br><span class="line">        IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            parseRequestFocus(parser, parent);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(TAG_TAG.equals(name)</span>) </span>&#123;</span><br><span class="line">            parseViewTag(parser, parent, attrs);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(TAG_INCLUDE.equals(name)</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, parent, attrs, inheritContext);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(TAG_MERGE.equals(name)</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = createViewFromTag(parent, name, attrs, inheritContext);</span><br><span class="line">            <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            rInflate(parser, view, attrs, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishInflate) parent.onFinishInflate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>===========================<br>以上就是 inflate 整个核心部分。</p>
<p>对于整体的流程，我画了流程图，如下</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;走了一遍 LayoutInflater的流程，特此记录&lt;/p&gt;
&lt;h3 id=&quot;获取_LayoutInflater_—-_LayoutInflater-from(context)&quot;&gt;获取 LayoutInflater —- &lt;code&gt;LayoutInflater.from
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[旧] LayoutInflater 后记--替换系统控件</title>
    <link href="http://dove.im/2016/11/19/%E6%97%A7-LayoutInflater-%E5%90%8E%E8%AE%B0-%E6%9B%BF%E6%8D%A2%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/"/>
    <id>http://dove.im/2016/11/19/旧-LayoutInflater-后记-替换系统控件/</id>
    <published>2016-11-19T06:30:00.000Z</published>
    <updated>2016-11-19T06:36:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前记录了自己走通 <code>LayoutInflater</code> 的源码整体流程，一直想搞个好玩的东西，想起之前看到过的<a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">换肤方案</a>，决定写个换系统控件的库。<br><a href="https://github.com/flyer88/Pichu" target="_blank" rel="external">项目地址</a>，项目的具体使用，可以看README</p>
<hr>
<h4 id="首先需要确定，LayoutInflater对于Android自带的view读入的名字是没有全名的，具体创建的时候是通过写上前缀，然后借助反射进行实例化的">首先需要确定，<code>LayoutInflater</code>对于<code>Android</code>自带的<code>view</code>读入的名字是没有全名的，具体创建的时候是通过写上前缀，然后借助反射进行实例化的</h4><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line"> ...</span><br><span class="line"> /&gt;</span><br></pre></td></tr></table></figure>
<p>作为xml读入以后，是只有<code>TextView</code>的<br>而</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dove.flyer.xu.mineView </span><br><span class="line">....    </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>作为xml读入后，是整个名字存在的，即<code>dove.flyer.xu.mineView</code>，具体细节<a href="">前面文章</a>已经叙述了，此处不重复了</p>
<h4 id="明确，Factory如果可以构建view对象的话，后面的view实例化操作是不会被进行的。">明确，<code>Factory</code>如果可以构建<code>view</code>对象的话，后面的<code>view</code>实例化操作是不会被进行的。</h4><p>首先定位到<code>createViewFromTag</code>。<br>源码中，以<code>Factory</code>为例子,如果<code>Factory</code>为空的时候，是不会执行里面代码的，如果设置了，则会执行。而执行后，如果<code>view</code>不为空，则下面的<code>view</code>创建都会失效，也就是说，如果<code>Factory</code>创建成功了<code>view</code>，那么后面创建<code>view</code>部分的代码并不会执行。<code>Facory2</code>也同理。<br>而<code>Factory</code>和<code>Factory2</code>在一开始就是空的，只需要设置好这个<code>Factory</code>，那具体的<code>view</code>创建就会被它俩其中一个接手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, AttributeSet attrs, <span class="keyword">boolean</span> inheritContext)</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    view = mFactory2.onCreateView(parent, name, viewContext, attrs);</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(mFactory != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">        view = mFactory.onCreateView(name, viewContext, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(view == <span class="keyword">null</span> ...)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(view == <span class="keyword">null</span> ...)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="明确Factory是可以被set进去的">明确<code>Factory</code>是可以被<code>set</code>进去的</h4><p>调用<code>getLayoutInflater().setFactory(factory)</code>即可</p>
<h4 id="剩下的就是考虑Activity会在何时才会创建view，自然是setContentView，该方法会触发整个xml的inflate，">剩下的就是考虑<code>Activity</code>会在何时才会创建<code>view</code>，自然是<code>setContentView</code>，该方法会触发整个<code>xml</code>的<code>inflate</code>，</h4><p>所以剩下的就是在<code>onCreate</code>的时候，在<code>setContentView</code>之前，把自己的<code>Factory</code>给设置进去，把传进来的名字，修改成自己的<code>view</code>就可以了。</p>
<hr>
<p>以上三点拼在一起就可以进行系统控件的同意替换，具体<code>Factory</code>重写的细节请参考源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前记录了自己走通 &lt;code&gt;LayoutInflater&lt;/code&gt; 的源码整体流程，一直想搞个好玩的东西，想起之前看到过的&lt;a href=&quot;https://github.com/fengjundev/Android-Skin-Loader&quot; target=&quot;_bla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[旧] Android 贝塞尔曲线，QQ 删除小红点类似效果实现</title>
    <link href="http://dove.im/2016/11/19/%E6%97%A7-Android-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%8CQQ-%E5%88%A0%E9%99%A4%E5%B0%8F%E7%BA%A2%E7%82%B9%E7%B1%BB%E4%BC%BC%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dove.im/2016/11/19/旧-Android-贝塞尔曲线，QQ-删除小红点类似效果实现/</id>
    <published>2016-11-19T06:29:51.000Z</published>
    <updated>2016-11-19T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p> 看到 QQ 拖动删除小红点的动画效果，就想着做个类似的效果，没找到Android 版的教程，于是就自己撸了一个，代码地址：<a href="https://github.com/flyer88/JellyCircle/tree/master/circleindicator" target="_blank" rel="external">https://github.com/flyer88/JellyCircle/tree/master/circleindicator</a> ，该栗子的实现在circleIndicator包中，app包下是另一个demo，还没写好。</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/indicator-01.gif" alt=""></p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/indicator-02.gif" alt=""></p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/indicator-03.gif" alt=""></p>
<p>注意：为实现上面链接中所示的动画，首先确定，两个圆随着偏移量的改变，半径大小出现了变化，同时贝塞尔曲线有所变化，那剩下的问题就是如何改变两个圆的半径大小，圆的位置，同时计算和绘制贝塞尔曲线</p>
<h1 id="接下来看具体的实现">接下来看具体的实现</h1><h3 id="首先偏移量">首先偏移量</h3><p>我此处给的值比较简单，直接通过<code>SeekBar</code>来获取偏移量<br>获取偏移量后，需要改变的数据有，半径大小，以及第二个圆的位置，以及贝塞尔曲线的重新绘制<br>具体代码如下：<br>​        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mEndCircle.setX(dpToPx(mDefaultFirstX + mMaxDistance * offset,getResources()));<span class="comment">//修改第二个圆的位置</span></span><br><span class="line">mEndCircle.setRadius(dpToPx(mDefaultMinRadius,getResources()) + offset * dpToPx(mDefaultMaxRadius - mDefaultMinRadius,getResources()));<span class="comment">//第二个圆半径变大</span></span><br><span class="line">mStartCircle.setRadius(dpToPx(mDefaultMaxRadius,getResources()) - offset * dpToPx(mDefaultMaxRadius - mDefaultMinRadius,getResources()));<span class="comment">//第一个圆半径变小</span></span><br><span class="line">mCanDrawBezier = calculatePoint(mStartCircle, mEndCircle);<span class="comment">//计算贝塞尔曲线</span></span><br><span class="line">invalidate();<span class="comment">//刷新，触发onDraw()，重新绘制</span></span><br></pre></td></tr></table></figure>
<h3 id="然后是计算贝塞尔曲线">然后是计算贝塞尔曲线</h3><p>看下图，基本上可以确定出有两条曲线，我没有画两条曲线，而是一条<code>mBezierPath</code>搞定<br>A-&gt;B-&gt;C-&gt;D-&gt;A（关于控制点哦o,p后面会有计算分析，基本按照上图中所写就可以计算出o,p两点的位置）<br><img src="http://ob9rvakdw.bkt.clouddn.com/14-51-38.jpg" alt=""><br>其中，A点是开始点，直接 <code>moveTo()</code> 即可，然后用<code>lineTo()</code>到B点,再调用系统自带的贝塞尔曲线方法<code>quadTo(ponitP.x,pointP.y)</code>计算即可，然后就是一样的<code>lineTo()</code>到D点，<code>quadTo(pointO.x,pointP.y)</code>;<br>关于<code>quadTo(x1,y1,x2,y2)</code>的使用，可以去百度一下，简单说一下，就是前面两个是控制点，后面两个是到达的点<br>这样<code>mBezierPath</code>基本就画好了，然后画起始圆和结束圆就可以了（当然，如果考虑到overdraw的话，起始可以用clipRect clipReject去掉重复的半圆，此处偷懒，直接画了两个圆，没有去掉重复绘制，或者直接画一个半圆，当然半圆的效果和圆是不一样的）<br>以下是构建出<code>mBezierPath</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mBezierPath.reset();</span><br><span class="line">mBezierPath.moveTo(mStartA.getX(), mStartA.getY());</span><br><span class="line">mBezierPath.lineTo(mStartB.getX(), mStartB.getY());</span><br><span class="line">mBezierPath.quadTo(mControlPointP.getX(), mControlPointP.getY(), mEndC.getX(), mEndC.getY());</span><br><span class="line">mBezierPath.lineTo(mEndD.getX(), mEndD.getY());</span><br><span class="line">mBezierPath.quadTo(mControlPointO.getX(), mControlPointO.getY(), mStartA.getX(), mStartA.getY());</span><br></pre></td></tr></table></figure>
<h3 id="接下来就是计算控制点o,p">接下来就是计算控制点o,p</h3><p>以图二简单的为例子，这种方式比较极端，计算比较容易，两个控制点p,o和H点重合，直接(R1(x,y)+R2(x,y))/2 = H(x,y)</p>
<p>图一也不麻烦，根据图一标注θ也可以算出o,p两点的x,y,具体实现可以看github代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 看到 QQ 拖动删除小红点的动画效果，就想着做个类似的效果，没找到Android 版的教程，于是就自己撸了一个，代码地址：&lt;a href=&quot;https://github.com/flyer88/JellyCircle/tree/master/circleindicator
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[旧]引用传递和值传递(pass by value vs pass by reference)</title>
    <link href="http://dove.im/2016/11/19/%E6%97%A7-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92-pass-by-value-vs-pass-by-reference/"/>
    <id>http://dove.im/2016/11/19/旧-引用传递和值传递-pass-by-value-vs-pass-by-reference/</id>
    <published>2016-11-19T06:29:39.000Z</published>
    <updated>2016-11-19T06:37:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录这个的原因主要是今天看到了<a href="https://www.zhihu.com/question/31203609" target="_blank" rel="external">知乎的一个问题</a>，发现自己有些地方有点懵逼，写下来记录一下，<a href="http://zhihu.com/question/31203609/answer/50992895" target="_blank" rel="external">知乎上排名第一的答案</a>说的很清楚，不过看了以后依旧有点迷迷糊糊，所以自己写了个几行代码测试。<br>首先上一个，感觉比较对的结论：<br><strong>Horstmann的《java核心技术》（中文第8版P115-P117）原文描述：<br>”java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。“<br>”有些程序员（甚至是本书的作者），认为java程序设计语言对对象采用的是引用调用，实际上这种理解是不对的。”</strong><br>然后补充几句我的理解：</p>
<ol>
<li>首先，Java在传递过程中，传递的只有值，但是表现出来的形式，却既有值传递也有引用传递，因此，没必要纠结于名字，能理解原理即可。</li>
<li>在传递对象进函数时，对象的所有数据会被拷贝到局部变量中，这也就导致了局部变量修改其成员变量值时会导致原始的变量的成员变量值产生响应的改变，因为他们持有的成员变量的引用指向了同一个地址块(内存空间)。</li>
<li>而对于传递8种基本变量时，也只是拷贝了值，因此对基本变量其本身的修改，无法导致原始变量的的修改。</li>
<li>不过这里需要考虑特殊情况，就是String，其表现形式和8种基本变量一样，具体下文有分析，而对于String为何要这么做，我也不清楚，不是很懂 jvm 和 Java 的设计。</li>
</ol>
<hr>
<hr>
<h2 id="一-_值类型和引用类型（此处先不考虑String）的传递：">一. 值类型和引用类型（此处先不考虑String）的传递：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(student.age);<span class="comment">//10</span></span><br><span class="line">        addAge(student);</span><br><span class="line">        System.out.println(student.age);<span class="comment">//11</span></span><br><span class="line">        addAge(student.age);</span><br><span class="line">        System.out.println(student.age);<span class="comment">//11</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAge</span><span class="params">(Student paramStudent)</span></span>&#123;</span><br><span class="line">        paramStudent.age = <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAge</span><span class="params">(<span class="keyword">int</span> paramAge)</span></span>&#123;</span><br><span class="line">        paramAge = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对以上代码进行解释</p>
<ul>
<li>首先<code>addAge(student)</code>调用的是<code>addAge(Student paramStudent)</code>，该部分其实很好理解，首先，<code>paramStudet</code>对象，拷贝了传入的<code>studet</code>对象所有的数据，因此<code>paramStudet</code>它所指向的地址，其实和<code>student</code>是一样的，所以，当<code>paramStudent</code>改变它的<code>age</code>值时，其触发的操作和<code>student</code>改变<code>age</code>的值是一样的 ,因为他们都指向了同一个地址块。</li>
<li>其次<code>addAge(student.age)</code>调用的是<code>addAge(int paramAge)</code>，也很好理解，<code>paramAge</code>也只是拷贝了<code>studet.age</code>的值，此处为10，然后改变了<code>paramAge</code>的值，但此时<code>paramAge</code>与引用类型不同，它保存的只有一个值，所以其实这个<code>parmaAge</code>作为一个局部变量，并不能对原本的<code>student.age</code>产生任何影响</li>
</ul>
<h2 id="二-_String的问题：">二. String的问题：</h2><h3 id="1-_String问题来源">1. String问题来源</h3><p>上面的例子其实很好搞清楚，但是我在碰到String的时候就有点懵逼了,如果调用以下方法，结果会如注释显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.age = <span class="number">10</span>;</span><br><span class="line">    student.name = <span class="string">"dove"</span>;</span><br><span class="line">    changeName(student);</span><br><span class="line">    System.out.println(student.name);<span class="comment">//dove_2</span></span><br><span class="line">    changeName(student.name);</span><br><span class="line">    System.out.println(student.name);<span class="comment">//dove_2</span></span><br><span class="line">    changeName2(student.name); </span><br><span class="line">    System.out.println(student.name);<span class="comment">//dove_2         </span></span><br><span class="line">&#125;      </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(Student paramStudent)</span></span>&#123;</span><br><span class="line">    paramStudent.name = <span class="string">"dove_2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(String paramName)</span></span>&#123;</span><br><span class="line">    paramName = <span class="string">"dove_3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName2</span><span class="params">(String paramName)</span></span>&#123;</span><br><span class="line">    paramName += <span class="string">"233"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>changeName2(String paramName)</code>此处讲道理被调用后应该是”dove_2233”,因为<code>String</code>是一个引用类型,也就是说此处的<code>parmaName</code>应该是指向和传入的参数指向了相同的一个地址块，然后对指向的内存进行了修改,然而结果并不是,原因就在于<code>String</code>是一个不可变的类型(为啥不可变呢,具体可以看<code>String</code>类的实现,它是一个<code>final class</code>,并且其内部正真保存着字符串的<code>value[]</code>也是不可变的(<code>final</code>)，所以意味着修改<code>Sting</code>是不可能的)。</p>
<h3 id="2-脑洞猜想可能情况">2.脑洞猜想可能情况</h3><p>所以猜测上述的<code>changeName2</code>过程类似于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FuckString fuckString = <span class="keyword">new</span> FuckString();<span class="comment">//paramName</span></span><br><span class="line">FuckString fuckString2 = <span class="keyword">new</span> FuckString(fuckString);<span class="comment">//构造出的新的值</span></span><br><span class="line">fuckString = fuckString2;<span class="comment">//把paramName指向构造出的新值</span></span><br></pre></td></tr></table></figure>
<p>然后，这就有点想不通了，不可变的类型，String 的 <code>+</code> 是怎么弄的呢？打个断点试试看，强制进入，发现跳转到了StringBuilder的构造方法里，这说明应该是构造了一个新的StringBuilder对象。      </p>
<p><img src="~/19-58-14.jpg" alt=""></p>
<p>同时，底部的Debug里抛出了个错误，说是无法获取<code>StringBuilder.toString()</code>,也就进一步证明此处有新的<code>String</code>的产生。<br><img src="http://ob9rvakdw.bkt.clouddn.com/19-58-59.jpg" alt=""><br>到这里基本上就验证了我的猜想，<code>String</code> <code>+</code>会产生一个新的<code>String</code>对象，既然这样，反编译下，看下字节码，估计基本就搞定这个懵逼的问题了。</p>
<h3 id="3-字节码验证">3.字节码验证</h3><p>于是就写了以下的类，用来验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">"dove"</span>;</span><br><span class="line">        s += <span class="string">"233"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后javac，然后javap -c，看字节码,如下图。</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/20-03-38.png" alt=""><br>尝试着解释下该部分代码（不是很看的懂字节码，所以有些解释可能不是很规范，不过讲道理大概意思不会差很远)</p>
<ul>
<li><code>String s = &quot;dove&quot;;</code>部分字节码及解释</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  // String dove&#10;2: astore_1</span><br></pre></td></tr></table></figure>
<p>第0行，将一个常量加载到操作数栈,也就是把“dove”这玩意，放进了操作数栈(也不知道是什么东西，蛤蛤)<br>第2行，将一号数值（下划线1代表一号，大概理解，不是很准确）从操作数栈存储到局部变量表，说白了就是把“dove”给存了起来？</p>
<ul>
<li><code>s += &quot;233&quot;;</code>部分字节码及解释</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> 3: new           #3                  // class java/lang/StringBuilder&#10; 6: dup&#10; 7: invokespecial #4                  // Method java/lang/StringBuilder.&#34;&#60;init&#62;&#34;:()V&#10;10: aload_1    &#10;11: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&#10;14: ldc           #6                  // String 233&#10;16: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&#10;19: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br></pre></td></tr></table></figure>
<p>第3行，这个很明显，不google也知道，<code>new StringBuilder()</code>，也就是搞了个<code>StringBUilder</code>的实例。<br>第6行，Java虚拟机提供了一些用于直接操作操作数栈，不是很懂，貌似对整体理解影响不大，先过。<br>第7行，invokespecial 调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法，此处应该是在初始化StringBuilder对象。<br>第10行，将1号局部变量(下划线1指代一号变量)加载到操作栈，这里应该是指“dove”<br>第11行，调用对象的实例方法,此处就是调用<code>StringBuilder.append</code>,也就是把“dove”加到了<code>StringBuilder</code>中<br>第14行，将一个常量加载到操作数栈，就是把“233”载入<br>第16行，调用对象的实例方法,此处就是调用<code>StringBuilder.append</code>，把“233”给加到“StringBuilder”中<br>第19行，调用对象的实例方法,此处就是调用<code>StringBuilder.toString</code>，而该方法，会触发<code>new String()</code>的操作，因此，会返还一个新的<code>String</code>对象</p>
<h3 id="4-最终结论：">4.最终结论：</h3><p>从脑洞断点以及最后的字节码分析可以看出，<code>s +=&quot;233&quot;</code>,会导致一个新的String对象生成，也就是说，调用<code>changeName2(String paramName)</code>会使得<code>paramName</code>指向一个新的String对象，这样就意味着，对该数据的改变并不会影响本身<code>student.name</code>的值,由此，String懵逼的问题也解决了。</p>
<hr>
<hr>
<p>以上，就是整个关于Java引用传递和值传递的理解，有说的不对的，望指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录这个的原因主要是今天看到了&lt;a href=&quot;https://www.zhihu.com/question/31203609&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎的一个问题&lt;/a&gt;，发现自己有些地方有点懵逼，写下来记录一下，&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[旧]Android 代码混淆(二)</title>
    <link href="http://dove.im/2016/11/19/%E6%97%A7-Android-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86-%E4%BA%8C/"/>
    <id>http://dove.im/2016/11/19/旧-Android-代码混淆-二/</id>
    <published>2016-11-19T06:29:28.000Z</published>
    <updated>2016-11-19T07:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android 代码混淆(一) 中已经记录并走了混淆的整个流程，用命令行进行混淆的操作，并验证了三个过程，这篇文章会记录一下在 <code>Android Studio</code> 下混淆的操作，以及具体需要的注意的一些事项。</p>
<h4 id="基本操作及整体的流程">基本操作及整体的流程</h4><p>1.修改<code>build.gradle</code>脚本</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span><span class="comment">//开启混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//配置内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span><span class="comment">//开启混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span><span class="comment">//配置内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2.修改proguard-rules.pro文件，写入基础的几个混淆规则，避开<code>Android</code>自带的一些类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 四大组件及基本类</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Application</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Service</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">BroadcastReceiver</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">ContentProvider</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">backup</span>.<span class="title">BackupAgentHelper</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">preference</span>.<span class="title">Preference</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">annotation</span>.**</span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v7</span>.**</span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Notification</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> <span class="title">android</span>.<span class="title">webkit</span>.**</span><br><span class="line">#保护<span class="title">WebView</span>对<span class="title">HTML</span>页面的<span class="title">API</span>不被混淆</span><br><span class="line">-<span class="title">keep</span> <span class="title">class</span> **.<span class="title">Webview2JsInterface</span> </span>&#123;*; &#125;</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Dialog</span></span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span></span><br><span class="line"></span><br><span class="line"># 所有枚举类型不要混淆</span><br><span class="line">-<span class="title">keepclassmembers</span> <span class="title">enum</span> * </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> **[] values();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 保持 <span class="keyword">native</span> 方法不被混淆</span><br><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line"><span class="keyword">native</span> &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保持R文件不被混淆，否则，你的反射是获取不到资源id的</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>*</span>&#123;*;&#125;</span><br><span class="line"></span><br><span class="line"># parcelable 不被混淆</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> finalandroid.os.ParcelableCreator *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保持实现<span class="string">"Serializable"</span>接口的类不被混淆</span><br><span class="line">-keepnames <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span><br><span class="line"></span><br><span class="line">#保护实现接口<span class="title">Serializable</span>的类中，指定规则的类成员不被混淆</span><br><span class="line">-<span class="title">keepclassmembers</span> <span class="title">class</span> * <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">!<span class="keyword">static</span> !<span class="keyword">transient</span> &lt;fields&gt;;</span><br><span class="line">!<span class="keyword">private</span> &lt;methods&gt;;</span><br><span class="line">!<span class="keyword">private</span> &lt;methods&gt;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream)</span></span>;</span><br><span class="line">java.lang.<span class="function">Object <span class="title">writeReplace</span><span class="params">()</span></span>;</span><br><span class="line">java.lang.<span class="function">Object <span class="title">readResolve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.直接跑一个debug版的进行测试，把打包好的APK修改成.zip文件，解压，取出文件中dex包。</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/11-30-16.jpg" alt=""><br>把解压获取的<code>dex</code>文件，通过 <a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="external">dex2jar工具</a> (一个把<code>dex</code>包转换成<code>jar</code>包的工具)，把<code>dex</code>转换成<code>jar</code>包。其具体使用不在此详细讲。<br>下图中我没有把d2j-dex2jar配置进环境变量，所以进入对应目录跑的脚本。<br><img src="http://ob9rvakdw.bkt.clouddn.com/11-35-36.jpg" alt=""></p>
<p>运行完后可以看到，当前目录下多了一个<code>classes-dex2jar.jar</code>的文件</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/11-37-26.jpg" alt=""></p>
<p>接下来就是和前一篇文章一样，直接用<code>Intelij</code>导入，看class文件，包内类名字已有变化，部分类已被移除，同时部分类也被改成final类型。具体就不上图了。主要看下面的注意事项。</p>
<h4 id="注意事项">注意事项</h4><p>上述流程在如果是项目一开始就进行混淆，大部分情况下是能够成功混淆，并且不会出现很大问题，只需要在项目进行过程中注意，新加的第三方类库，反射代码。但是，如果你面对的是一个沉积已久，并且项目庞大，而又从未写过混淆的项目，那你可能会在混淆开启时，面临几千个混淆时的<code>warning</code>和<code>note</code>，最终无法编译通过。这中间主要是大量第三方库的报错。下面记录一下我在处理这种情况时，遇到的问题以及解决方案</p>
<h5 id="warning_处理">warning 处理</h5><p>写了个<a href="https://github.com/flyer88/Some_Python_For_Android" target="_blank" rel="external">脚本</a>,，过滤出大部分错误，生成proguard文件，然后继续处理剩下的个别遗留问题</p>
<p>写几个典型的例子：</p>
<p>1.情况一:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: xxxxxx calls <span class="string">'Class.getEnclosingMethod'</span></span><br><span class="line">#这种情况就是调用了反射，找到xxxxx对应调用的类，并且设为入口点</span><br></pre></td></tr></table></figure>
<p>2.情况二:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Warning: AAAAAAA: can't find superclass or interface BBBBBBB</span><br><span class="line">Warning: AAAAAAA: can't find referenced class BBBBBBB </span><br><span class="line">#这两种种情况就是找不到BBBBBB了，直接把BBBBB设为入口点，同时给AAAAA打上-dontwarn既可以,如下</span><br><span class="line">-keep class BBBBBB</span><br><span class="line">-dontwarn AAAAAA</span><br></pre></td></tr></table></figure>
<p>3.情况三:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Note:AAAAA accesses a declared field BBBBB dynamically </span><br><span class="line">    Maybe <span class="keyword">this</span> is program field <span class="string">'CCCCC'</span></span><br><span class="line">    Maybe .....</span><br><span class="line">#这种情况下，需要处理CCCC,把它设为入口点，同样设置对AAAAA设置-dontwarn</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">CCCCC</span></span><br><span class="line">#不一定是-<span class="title">keep</span>，也有可能其他的，例如 -<span class="title">keepattribute</span> 更为合适</span><br><span class="line">-<span class="title">dontwarn</span> <span class="title">AAAAA</span></span></span><br></pre></td></tr></table></figure>
<h5 id="多个_module_的混淆">多个 module 的混淆</h5><p>有时候会碰到多个<code>module</code>混淆的情况,多数情况下，为了清晰处理会给每个<code>module</code>都写上对应的混淆规则，同时需要修改<code>build.gradle</code>的配置，而不是之前的写法，具体可以参考<a href="http://stackoverflow.com/questions/30820915/android-studio-proguard-handling-in-multi-library-projects" target="_blank" rel="external">so上的解释</a><br>这种方案，需要<code>module</code>之间的依赖清晰，最底层的<code>module</code>会被最先混淆，然后一步一步倒推上去，知道主<code>module</code>,多为<code>app module</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        consumerProguardFiles <span class="string">'proguard-project.txt'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，我碰到的情况则是，多个<code>module</code>中有相同的包名，这时候视图去每个<code>module</code>自顾自混淆的情况下是不可能。因为同包名的情况下，混淆器是无法一个一个<code>module</code>的进行混淆。</p>
<p>所以最终的解决方案是，面对这种项目，还是在主<code>module</code>中进行混淆吧。</p>
<h5 id="反射的处理">反射的处理</h5><p>反射举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; a = Class.forName(<span class="string">"com.dove.xu.a"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">xu</span>.<span class="title">a</span></span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>
<p>不过，此处在考虑到自己代码的同时，需要注意第三方类库。类似的<code>json</code>处理库，<code>retrofit</code>等都是有反射代码的。</p>
<h5 id="JavaScript_的处理">JavaScript 的处理</h5><p>处理方案和上面的反射类似<br>keep 掉需要调用 java 代码方法，或者类即可<br>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">WebInterface</span></span>&#123;</span><br><span class="line">    WebInterface()&#123;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callBackAndroid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Toast.make....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混淆规则只需要加上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">xu</span>.<span class="title">WebInterface</span></span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常用系统和第三方库的混淆规则">常用系统和第三方库的混淆规则</h5><p>下面这个github库收藏了大量第三方库的混淆规则，可以去看一下<br><a href="https://github.com/krschultz/android-proguard-snippets" target="_blank" rel="external">snippets</a><br>基本的系统混淆规则，在一开始则整体流程中也已记录，就不重复了。<br>最后，需要注意的是网上也会有大量现成的第三方类库的混淆规则。但是在抄的时候也需要注意，不同的版本混淆规则不一定相同，所以一定要注意，在拷贝完以后，看一下规则，是否符合自己的版本，包名是否正确。<br>举个自己碰到的例子：<br><a href="https://github.com/JakeWharton/butterknife/blob/master/butterknife/proguard-rules.txt" target="_blank" rel="external">Butterknife 8.2.1 混淆规则,摘自官方github</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Retain generated <span class="class"><span class="keyword">class</span> <span class="title">which</span> <span class="title">implement</span> <span class="title">ViewBinder</span>.</span><br><span class="line">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">implements</span> <span class="title">butterknife</span>.<span class="title">internal</span>.<span class="title">ViewBinder</span> </span>&#123; <span class="keyword">public</span> &lt;init&gt;(); &#125;</span><br><span class="line"></span><br><span class="line"># Prevent obfuscation of types which use ButterKnife annotations since the simple name</span><br><span class="line"># is used to reflectively look up the generated ViewBinder.</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">butterknife</span>.*</span><br><span class="line">-<span class="title">keepclasseswithmembernames</span> <span class="title">class</span> * </span>&#123; <span class="annotation">@butterknife</span>.* &lt;methods&gt;; &#125;</span><br><span class="line">-keepclasseswithmembernames <span class="class"><span class="keyword">class</span> * </span>&#123; <span class="annotation">@butterknife</span>.* &lt;fields&gt;; &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/chalup/proguard-please-repo/blob/master/com.jakewharton/butterknife/5.1.2/proguard.cfg" target="_blank" rel="external">Butterknife 5.1.2 混淆规则，摘自官方github</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn butterknife.internal.**</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> **$$<span class="title">ViewInjector</span> </span>&#123; *; &#125;</span><br><span class="line">-keepnames <span class="class"><span class="keyword">class</span> * </span>&#123; <span class="annotation">@butterknife</span>.InjectView *;&#125;</span><br></pre></td></tr></table></figure>
<p>注:此处因学长提到<code>@</code>的问题，后来查看官方文档，如下:</p>
<p>The @ specifications can be used to restrict classes and class members to the ones that are annotated with the specified annotation types. An annotationtype is specified just like a classname.</p>
<p>上面大概的意思就是说，@符号可以用来标记注解类，用法和一般类一样<br>即，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepnames <span class="class"><span class="keyword">class</span> * </span>&#123; <span class="annotation">@butterknife</span>.InjectView *;&#125;</span><br></pre></td></tr></table></figure>
<p>此处的意思是，避开所有类中，有<code>butterknife.InjectView</code>注解的任何变量，方法等，其中<code>butterknife</code>是指包名，即<code>InjectView</code>的完整引用，参考下图：</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/21-24-45.jpg" alt=""></p>
<h5 id="@keep_注解来避开混淆">@keep 注解来避开混淆</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止混淆类</span></span><br><span class="line"><span class="annotation">@Keep</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止混淆变量</span></span><br><span class="line"><span class="annotation">@Keep</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//防止混淆方法</span></span><br><span class="line"><span class="annotation">@Keep</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>需要手动开启注解避开混淆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#http:<span class="comment">//tools.android.com/tech-docs/support-    annotations</span></span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line">-printconfiguration</span><br><span class="line">-keep,allowobfuscation <span class="annotation">@interface</span>         android.support.annotation.Keep</span><br><span class="line"></span><br><span class="line">-keep <span class="annotation">@android</span>.support.annotation.Keep <span class="class"><span class="keyword">class</span> *</span><br><span class="line">-<span class="title">keepclassmembers</span> <span class="title">class</span> * </span>&#123;</span><br><span class="line">    <span class="annotation">@android</span>.support.annotation.Keep *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>以上就是我在Android混淆时，学到的知识以及碰到的问题。特此记录</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 代码混淆(一) 中已经记录并走了混淆的整个流程，用命令行进行混淆的操作，并验证了三个过程，这篇文章会记录一下在 &lt;code&gt;Android Studio&lt;/code&gt; 下混淆的操作，以及具体需要的注意的一些事项。&lt;/p&gt;
&lt;h4 id=&quot;基本操作及整体的流程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[旧]Android 代码混淆(一)</title>
    <link href="http://dove.im/2016/11/19/%E6%97%A7-Android-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86-%E4%B8%80/"/>
    <id>http://dove.im/2016/11/19/旧-Android-代码混淆-一/</id>
    <published>2016-11-19T06:29:03.000Z</published>
    <updated>2016-11-19T07:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文前半部分对照 <a href="http://proguard.sourceforge.net" target="_blank" rel="external">Proguard 文档 (Manul 中的 Introduce 部分)</a>进行翻译同时加上个人的理解，如果有与原文不同，请以原文为主。后半部分是对几个步骤的验证。</p>
<hr>
<h2 id="介绍">介绍</h2><p>混淆器(ProGuard)会对 Java class 文件进行 shrinker(压缩)，optimizer(优化)，obfuscator(混淆)以及preverifier(校验)。shrinker(压缩)这一步会找到并移除没用到的类，变量，方法，属性。optimization(优化)这一步，会分析并且优化方法的字节码。obfuscation(混淆)则会对 class，fields，methods替换成一些短的无意义的名字。第一步会把代码量变小，运行更加有效率，同时更加难以被逆向。在 Java Micro Edition 和 Java 6或者更高版本中，最后一步的检验过程，会向class文件中添加一些预校验的信息。<br>上述的每个步骤，都是可以选择的(可以进行也可以不进行)。例如，ProGuard 可以只进行preverify，从而更高效的运行。</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/21-59-04.jpg" alt=""></p>
<ul>
<li>首先，ProGuard(混淆器) 读入输入的 jars (也可以是 aars, wars, ears, zips, apks, 或者目录)。随后，开始进行 shrinker(压缩)，optimizer(优化)，obfuscator(混淆)以及preverifier(校验)。你可以选择性的让ProGuard(混淆器)进行多种类型的优化操作。ProGuard(混淆器)会把修改过的结果写入一个或者多个输出的 jars (也可以是 aars, wars, ears, zips, apks, 或者目录)中。</li>
<li>混淆器需要明确输入文件(Input jars)是jars包(也可以是 aars, wars, ears, zips, apks, 或者目录)。这些 libraries 本质上是你将会用来编译的代码。混淆器为了能够正确进行整个过程，会重新构建类之间的依赖。而依赖包(Library jars) 往往是不会被改变的，但你依旧需要把它们放在最终的App的环境中。</li>
</ul>
<h4 id="Entry_points(入口点)">Entry points(入口点)</h4><ul>
<li>在压缩步骤(shrinker)，混淆器会从这些点(入口点)进入，并且递归寻找决定哪些类和哪些类成员会被使用。所有的其他类和类成员都会被抛弃掉</li>
<li>在优化步骤(optimizer)，混淆器会进一步优化代码。在这些优化过程中，那些不是入口点的类和方法会变成private static或者final，不被用到的参数会被移除，一些方法会变成内敛方法</li>
<li>在混淆这一步(obfuscator)，混淆器会重新命名那些不是入口点的类和类的成员。在这整个过程中，那些成为入口点的地方，依旧会为他们保留原来的名字</li>
<li>预验证阶段(preverifier)是唯一一个不需要知道入口点的阶段</li>
</ul>
<h4 id="反射(该部分内容具体处理和理解，会在下一文章中进行具体的记录)">反射(该部分内容具体处理和理解，会在下一文章中进行具体的记录)</h4><ul>
<li>对于反射和introspection 进行代码的自动处理时，都会存在一些特殊的问题。在混淆器进行处理时，代码中类和类成员都是被动态创建或者被动态调用的(通过对应类的名字，或者成员名字)，这些地方都必须被定义成入口点。例如，<code>Class.forName()</code>这个构造器会在运行时指向任何的类。又比如，类的名字可能会从配置文件中读入，这通常很难去计算出是那些类需要被保留(通过原始的名字)。因此，你必须得在混淆器的配置中，通过简单相同的操作<code>-keep</code>来指定他们。<br>然而，混淆器已经能够帮你发现并处理以下的情况：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"SomeClass"</span>)</span><br><span class="line">SomeClass.class</span><br><span class="line">SomeClass.class.getField(<span class="string">"someField"</span>)</span><br><span class="line">SomeClass.class.getDeclaredField(<span class="string">"someField"</span>)</span><br><span class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123;&#125;)</span><br><span class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class &#125;)</span><br><span class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class, B.class &#125;)</span><br><span class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123;&#125;)</span><br><span class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class &#125;)</span><br><span class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class, B.class &#125;)</span><br><span class="line">AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, <span class="string">"someField"</span>)</span><br><span class="line">AtomicLongFieldUpdater.newUpdater(SomeClass.class, <span class="string">"someField"</span>)</span><br><span class="line">AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, <span class="string">"someField"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>类和类成员的名字会不一样，但是构造方法必然是相同的，由此，混淆器能够认出他们。被引用的类和类的成员在压缩(shrinking)阶段会被保留，同时，string 类型的参数也会在混淆时(obfuscation)被准确的修改。</li>
<li>除此之外，混淆器会提供一些建议：是否保留一些出现的类和类成员。举例，混淆器会标记<code>(SomeClass)Class.forName(variable).newInstance()</code>这样的构造器。因为这些方法可能会指向其他类，这些可能是类，也可能是接口，或者是继承自这些接口或者类的类。你需要在配置中做相应的处理。</li>
<li>为了能够得到正确的混淆结果，你应该对进行混淆的代码多少有所熟悉。当面临大量反射代码时，混淆代码需要进行大量的试验，并处理错误，特别是对于内部代码没有足够的信息的情况下    </li>
</ul>
<hr>
<p>以上是对<a href="http://proguard.sourceforge.net" target="_blank" rel="external">官方文档首页</a>的翻译内容</p>
<h2 id="具体的验证">具体的验证</h2><p>该部分不是翻译内容，是根据<a href="http://proguard.sourceforge.net/manual/usage.html" target="_blank" rel="external">ProGuard 的使用方法</a>和<a href="http://proguard.sourceforge.net" target="_blank" rel="external">文档首页</a>，对上述三个步骤的具体验证。<br>由于大部分情况下，<code>Android</code>的混淆只需要考虑<code>Obfuse</code>这个步骤，因为很多第三方依赖包的混淆规则会把 <code>shrink</code>和<code>optimize</code>去掉（比如友盟）。所以先验证这一步。<br>下面的验证步骤，涉及三个类，java打包的命令(Java 环境)，<code>proguard.ja</code>r包(混淆器，进行整个混淆过程的jar包)，<code>proguard.pro</code>文件(写入具体混淆的规则)和<code>Intelij</code>(用来查看<code>class</code>文件)等内容。</p>
<h4 id="Obfuse_步骤验证">Obfuse 步骤验证</h4><p>这个步骤，如上所说，主要是对类，方法进行名字的修改，也是 Android 混淆中最重要的部分。为了验证这个过程，我做了下面的demo操作</p>
<ul>
<li>首先写了3个类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dove.home;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dove.home;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloWorld2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello World2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dove.home;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HelloWorld helloWorld = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后编译,打包</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac com/dove/home/Main.java&#10;javac com/dove/home/HelloWorld2.java&#10;javac com/dove/home/HelloWorld.java&#10;//&#27880;&#24847;&#22312;&#36827;&#34892;&#19979;&#38754;&#27493;&#39588;&#30340;&#26102;&#20505;&#65292;&#25105;&#25226; com/dove/home &#19979;&#30340; java&#28304;&#30721;&#21024;&#20102;&#10;jar -cvf main_source.jar com</span><br></pre></td></tr></table></figure>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/18-39-05.jpg" alt=""></p>
<ul>
<li>然后使用混淆器，混淆器其具体使用方法，主要是调用<code>proguard.jar</code>包，然后配置 <code>proguard.pro</code>文件进行具体的参数设置。</li>
</ul>
<p>下面是我<code>proguard.pro</code>文件内容</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 源码文件</span><br><span class="line">-<span class="ruby">injars main_source.jar</span><br><span class="line"></span># 混淆后输出文件</span><br><span class="line">-<span class="ruby">outjars main_source_out.jar</span><br><span class="line"></span># java 核心 jar 不能混淆</span><br><span class="line">-<span class="ruby">libraryjars &lt;java.home&gt;<span class="regexp">/lib/rt</span>.jar</span><br><span class="line"></span>-<span class="ruby">libraryjars &lt;java.home&gt;<span class="regexp">/lib/jce</span>.jar</span><br><span class="line"></span># 全部不混淆，即三个class文件都会保持原样</span><br><span class="line">-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">Main</span>&#123;*;</span>&#125;</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">HelloWorld</span>&#123;*;</span>&#125;</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">HelloWorld2</span>&#123;*;</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>具体的混淆命令，同时参考下图(该步骤会生成混淆后的jar包)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">java</span> -jar proguard.jar <span class="variable">@proguard</span>.pro</span><br></pre></td></tr></table></figure>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/17-45-40.jpg" alt=""></p>
<p>注意：然后修改 proguard.pro 文件，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-injars main_source.jar</span><br><span class="line"># 注意输出包的名字改了</span><br><span class="line">-outjars main_source_proguard_out.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">Main</span></span>&#123;*;&#125;</span><br><span class="line"># 删除了HelloWorld的 keep</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">HelloWorld2</span></span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>
<p>同样运行上面的混淆命令，生成另一个混淆后的包</p>
<p>最后对三个包进行对比，通过代码逆向，进行验证，最快的方式是把生成的 jar 包，当做第三方依赖包直接导入Intellij 中(有decode的功能)，如下图，三个包的区别</p>
<p><img src="http://ob9rvakdw.bkt.clouddn.com/18-48-53.jpg" alt=""></p>
<p>最初是的源码包和保留<code>HelloWorld</code>,<code>HelloWorld2</code>以及<code>Main</code>入口点的包是一样的，不同的是最后没有保留<code>HelloWorld</code>入口点的包，它的<code>HelloWorld</code>变成了<code>a</code>，而<code>Main</code>和<code>HelloWorld2</code>都正常没有被修改</p>
<h4 id="Optimize_步骤验证">Optimize 步骤验证</h4><p>同样，修改 proguard.pro 文件，内容如下，然后运行混淆命令，生成新的 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-injars main_source.jar</span><br><span class="line"># 输出包名改了，方便对比</span><br><span class="line">-outjars main_source_proguard_not_optimize_out.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</span><br><span class="line"># 加上不进行优化的限制</span><br><span class="line">-dontoptimize</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">Main</span></span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">HelloWorld2</span></span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>
<p>同上，导入IntelliJ，对比上一步中混淆后的 jar 包，发现名字没啥变化，但内容不一样了<br><img src="http://ob9rvakdw.bkt.clouddn.com/18-51-28.jpg" alt=""><br>首先是没有添加 <code>-dontoptimize</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dove.home;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是添加了 <code>-dontoptimize</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dove.home;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述译文中所说，optimize 会进行代码优化，不是入口点的代码，会变成<code>final</code>，<code>private</code>等等，该步骤验证完毕。</p>
<h4 id="Shrink_步骤验证">Shrink 步骤验证</h4><p>修改 proguard.pro 文件，进行压缩，同时不对 HelloWorld，HelloWorld2进行入口点的保留</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-injars main_source.jar</span><br><span class="line">-outjars main_source_proguard_shrink_out.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</span><br><span class="line"></span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">Main</span></span>&#123;*;&#125;</span><br><span class="line"># 注意对比之前，删除了HelloWorld和HelloWorld2的 keep</span><br></pre></td></tr></table></figure>
<p>修改 proguard.pro 文件，不进行压缩，同样不对 HelloWorld，HelloWorld2进行入口点的保留</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-injars main_source.jar</span><br><span class="line">-outjars main_source_proguard_not_shrink_out.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/rt.jar</span><br><span class="line">-libraryjars &lt;java.home&gt;/lib/jce.jar</span><br><span class="line"># 添加不进行压缩</span><br><span class="line">-dontshrink</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">dove</span>.<span class="title">home</span>.<span class="title">Main</span></span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>
<p>其结果对比<br>添加了 <code>-dontshrink</code>标志<br><img src="http://ob9rvakdw.bkt.clouddn.com/18-58-04.jpg" alt=""><br>未添加 <code>-dontshrink</code>标志<br><img src="http://ob9rvakdw.bkt.clouddn.com/18-58-16.jpg" alt=""><br>此处消失的<code>b</code>其实就是<code>HelloWorld2</code>，而留下的<code>a</code>则是<code>HelloWorld</code>,原因很简单，因为Main里面持有了<code>HelloWorld</code>的引用，而<code>HelloWorld2</code>则从未被用到，所以就被抛弃了。<br>由此验证，shrink阶段，Proguard(混淆器)会把无用类文件等删除，一些被动态获取的类就需要注意了，需要进行<code>-keep</code>操作，使其成为入口点。</p>
<hr>
<p>以上就是对混淆整个过程的验证</p>
<p>对于 Android 混淆，一些需要注意的东西，会在下一篇文章中记录</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文前半部分对照 &lt;a href=&quot;http://proguard.sourceforge.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Proguard 文档 (Manul 中的 Introduce 部分)&lt;/a&gt;进行翻译同时加上个人的理解，如果
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dagger2 学习(二)</title>
    <link href="http://dove.im/2016/11/18/dagger2-%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
    <id>http://dove.im/2016/11/18/dagger2-学习-二/</id>
    <published>2016-11-18T08:27:46.000Z</published>
    <updated>2016-11-21T08:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>之前记录了最简单的<code>Dagger 2</code>  使用，现在记录一下面对多层依赖时的问题，同时配合 <code>@Module</code> 进行注入的情况。</p>
<h3 id="A_多层依赖情况">A 多层依赖情况</h3><p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A02" target="_blank" rel="external">该部分代码A</a></p>
<h4 id="1-_多层依赖情况模拟">1. 多层依赖情况模拟</h4><p>添加 <code>ClassRoom</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    User mUser;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassRoom</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUser = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        mUser = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>MainActivity.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//@Inject User mUser;// 注释掉这行</span></span><br><span class="line"><span class="annotation">@Inject</span> ClassRoom mClassRoom;<span class="comment">// 添加这行注入</span></span><br><span class="line">...</span><br><span class="line">mUserAgeTv.setText(<span class="string">""</span> + mClassRoom.getUser().getAge());</span><br><span class="line"><span class="comment">// 修改获取方式，测试注入是否成功</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="2-_生成代码对比">2. 生成代码对比</h4><p><code>ClassRoom.java</code> =&gt; <code>ClassRoom_Factory.java</code> </p>
<p>编译，查看生成代码，多出一个 <code>ClassRoom_Factory</code>  ，效果和对 <code>User</code>  构造方法的注入是一样的。</p>
<p>重点关注 <code>DaggerUserComponent</code> 和 <code>MainActivity_MemberInjector</code> 的变化</p>
<h5 id="(1)_DaggerUserComponent-java_变化不大，主要是多了一个_Provider以及对应的初始化">(1) <code>DaggerUserComponent.java</code> 变化不大，主要是多了一个 Provider以及对应的初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Provider&lt;ClassRoom&gt; classRoomProvider;<span class="comment">// 多出一个 clssRoomProvider</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化方法变化，需要先初始化 classRoomProvider，然后再创建 mainActivityMembersInjector</span></span><br><span class="line">  	<span class="keyword">this</span>.classRoomProvider = ClassRoom_Factory.create(User_Factory.create());</span><br><span class="line">   	<span class="keyword">this</span>.mainActivityMembersInjector = MainActivity_MembersInjector.create(classRoomProvider);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 此处对<code>classRoomProvider</code>初始化 需要调用到他所依赖的 <code>User</code> 所生成的<code>User_Factory</code></p>
<p>这里也是处理依赖的地方，当 <code>ClassRoom</code> 生成需要 <code>User</code> 时，需要先提供 <code>User</code> 的生成者，也就是 <code>User_Factory</code></p>
</blockquote>
<h5 id="(2)_MainActivity_MemberInjector-java，变化也不大">(2) <code>MainActivity_MemberInjector.java</code>，变化也不大</h5><p>因为去掉了 <code>@Inject User mUser;</code> 这行，因此 <code>Provider&lt;User&gt; mUserProvider</code> 也就消失了。</p>
<p>其余部分，主要是从 <code>User</code> 转换到 <code>ClassRoom</code> 。具体可以参考下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;ClassRoom&gt; mClassRoomProvider;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_MembersInjector</span><span class="params">(Provider&lt;ClassRoom&gt; mClassRoomProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> mClassRoomProvider != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mClassRoomProvider = mClassRoomProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;MainActivity&gt; <span class="title">create</span><span class="params">(Provider&lt;ClassRoom&gt; mClassRoomProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainActivity_MembersInjector(mClassRoomProvider);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(MainActivity instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    instance.mClassRoom = mClassRoomProvider.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectMClassRoom</span><span class="params">(</span><br><span class="line">      MainActivity instance, Provider&lt;ClassRoom&gt; mClassRoomProvider)</span> </span>&#123;</span><br><span class="line">    instance.mClassRoom = mClassRoomProvider.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="(3)_总结">(3) 总结</h5><p>所以综上，当需要注入的对象，依赖另一个对象时，<code>Dagger 2</code> 编译 生成的代码，和原本的方法区别不是很大</p>
<p>最大变化主要是初始化 <code>DaggerUserComponent</code> 时候，多了对 <code>classRoomProvider</code> 的初始化赋值。</p>
<p>即 <code>A</code> 依赖 <code>B</code>  时，<code>Dagger</code>  在生成 <code>Component</code> 实例的时候，会调用 <code>B</code> 的<code>B_Factory</code>来生成 <code>mAProvider</code> </p>
<p>然后才能对 <code>mainActiivtyMembersInjector</code> 进行初始化</p>
<h3 id="B_配合@Module_解决多层依赖">B 配合<code>@Module</code> 解决多层依赖</h3><p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A02.1Module" target="_blank" rel="external">该部分代码B</a></p>
<h4 id="1-_总述">1. 总述</h4><p><code>@Module</code> 作用，某个模块依赖的提供者，<code>@Provides</code> 配合使用，其主要是下面两种情况：</p>
<ol>
<li>需要的依赖并没有存在实例，需要 <code>new</code> 出来</li>
<li>需要的依赖来自已经创建的或者已存在的对象</li>
</ol>
<h4 id="2-具体使用模拟">2.具体使用模拟</h4><p>此处先考虑实例 需要 <code>new</code> 出来这种情况。</p>
<p>添加 <code>Subject.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    String mName;</span><br><span class="line">    String mId;</span><br><span class="line">    ClassRoom mClassRoom;</span><br><span class="line">    User mUser;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(ClassRoom classRoom)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mName = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>.mId = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>.mClassRoom = classRoom;</span><br><span class="line">        <span class="keyword">this</span>.mUser = classRoom.getUser();</span><br><span class="line">    &#125;	</span><br><span class="line">  	...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加<code>SubjectModule.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectModule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectModule</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Provides</span> <span class="function">Subject <span class="title">provideSubject</span><span class="params">(ClassRoom classRoom)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subject(classRoom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>UserComponent.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>(modules = SubjectModule.class)<span class="comment">// 修改加入 modules 依赖</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>修改 <code>MainActivity.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    @Inject User mUser;</span></span><br><span class="line"><span class="comment">//    @Inject ClassRoom mClassRoom;</span></span><br><span class="line"><span class="comment">// 注释掉上面两行，添加 mSubject 的注入</span></span><br><span class="line">    <span class="annotation">@Inject</span> Subject mSubject;</span><br><span class="line">    SubjectModule mSubjectModule;</span><br><span class="line">	...</span><br><span class="line">    ...</span><br><span class="line">    mSubjectModule = <span class="keyword">new</span> SubjectModule();</span><br><span class="line"><span class="comment">// 注意此处调用方式已经变了，需要外部自己传入标记的 xxModule 类</span></span><br><span class="line">	DaggerUserComponent.builder()</span><br><span class="line">	  .subjectModule(mSubjectModule)</span><br><span class="line">	  .build().injectTo(<span class="keyword">this</span>);</span><br><span class="line">	mUserAgeTv.setText(<span class="string">""</span> + mSubject.mClassRoom.getUser().getAge());</span><br></pre></td></tr></table></figure>
<h4 id="3-_查看该部分内容对应生成的代码">3. 查看该部分内容对应生成的代码</h4><p>加入的修改的类有些多，所以再看一次其生成代码的对应关系</p>
<h5 id="(1)_SubjectModule-java_=&gt;_SubjectModule_ProvideSubjectFactory-java">(1) <code>SubjectModule.java</code> =&gt; <code>SubjectModule_ProvideSubjectFactory.java</code></h5><p><code>@Provides Subject provideSubject(ClassRoom classRoom)</code> 该注解，确定了 生成的 <code>xxx_ProvidexxxFactory</code> 需要用到的依赖，此处是<code>ClassRoom</code> 类，对应的是 <code>ClassRoom_Factory</code> ，下面具体的代码中也可看出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectModule_ProvideSubjectFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Subject</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubjectModule module;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;ClassRoom&gt; classRoomProvider;<span class="comment">// @provides 标记的函数所需要的依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubjectModule_ProvideSubjectFactory</span><span class="params">(</span><br><span class="line">      SubjectModule module, Provider&lt;ClassRoom&gt; classRoomProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> module != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.module = module;</span><br><span class="line">    <span class="keyword">assert</span> classRoomProvider != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.classRoomProvider = classRoomProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Subject <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get方法不一样，不是直接 new ，而是调用 SubjectModule.provideSubject() 方法</span></span><br><span class="line">    <span class="comment">// 而该方法依赖 ClassRoom 对象，因此需要调用到 classRoomProvider.get 来获取 ClassRoom 的实例</span></span><br><span class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</span><br><span class="line">        module.provideSubject(classRoomProvider.get()),</span><br><span class="line">        <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 该部分生成方法和以前的 ClassRoom_Factory 一样，有外层依赖，需要传入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Subject&gt; <span class="title">create</span><span class="params">(</span><br><span class="line">      SubjectModule module, Provider&lt;ClassRoom&gt; classRoomProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubjectModule_ProvideSubjectFactory(module, classRoomProvider);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="(2)_UserComponent-java_=&gt;_DaggerUserComponent-java">(2) <code>UserComponent.java</code> =&gt; <code>DaggerUserComponent.java</code></h5><p>主要关注点三个</p>
<p>a.该部分添加了<code>@Component(modules = SubjectModule.class)</code> ，整体调用上有变化，需要外部传入 <code>SubjectModule</code>的实例</p>
<p>b.同时多了一个 <code>Provider&lt;Subject&gt; provideSubjectProvider</code>  </p>
<p>c. 因为<code>Dagger2</code> 通过上述 (1) 中 <code>@Provides</code> 所标记的函数，所需要的依赖判断出需要<code>ClassRoom</code>的实例提供者 ，因此有<code>classRoomProvider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  	....  </span><br><span class="line">	<span class="keyword">private</span> Provider&lt;Subject&gt; provideSubjectProvider;</span><br><span class="line">	...</span><br><span class="line">  	...</span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.classRoomProvider = ClassRoom_Factory.create(User_Factory.create());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.provideSubjectProvider =</span><br><span class="line">          SubjectModule_ProvideSubjectFactory.create(builder.subjectModule, classRoomProvider);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.mainActivityMembersInjector = MainActivity_MembersInjector.create(provideSubjectProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectTo</span><span class="params">(MainActivity mainActivity)</span> </span>&#123;</span><br><span class="line">      mainActivityMembersInjector.injectMembers(mainActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> SubjectModule subjectModule;</span><br><span class="line">      ...</span><br><span class="line">      <span class="function"><span class="keyword">public</span> UserComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subjectModule == <span class="keyword">null</span>) &#123;<span class="comment">// 2 如果为空，dagger 会自己创建一个</span></span><br><span class="line">          <span class="keyword">this</span>.subjectModule = <span class="keyword">new</span> SubjectModule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DaggerUserComponent(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">// 1 构造的时候可以传入 subjectModule</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">subjectModule</span><span class="params">(SubjectModule subjectModule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subjectModule = Preconditions.checkNotNull(subjectModule);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>故而，配合调用链来看，上述代码注释中的 1，2需要注意</p>
<p>因为外部传入的 subjectModule 是由自己创建，控制的</p>
<p>而如果没有传入，<code>dagger</code> 会自动创建一个</p>
<p>如果当前 <code>DaggerUserComponent</code> 被重复使用，其 <code>subjectModule</code> 也会一直重复使用同一个</p>
<p>该部分具体看需求，不同情况不同使用</p>
</blockquote>
<h5 id="(3)MainActivity-java_=&gt;_MainActivity_MembersInjector-java">(3)<code>MainActivity.java</code> =&gt; <code>MainActivity_MembersInjector.java</code></h5><p>其中 <code>MainActivity_MembersInjecto.java</code> 修改很小，和上面A部分情况类似</p>
<p>因为去掉了 <code>@Inject ClassRoom mClassRoom;</code>  故而就是把A部分的中<code>mClassRoomProvider</code> =&gt; <code>mSubjectModule</code></p>
<h4 id="3-_第二种情况处理">3. 第二种情况处理</h4><p>我们需要从外面传入自己<code>new</code> 的实例，再调用 <code>Dagger</code> 来生成对应的实例。</p>
<p>可以借助 <code>SubjectModule</code> 构造函数，或者方法进行放入，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubjectModule mSubjectModule = <span class="keyword">new</span> SubjectModule(<span class="keyword">new</span> ClassRoom());</span><br><span class="line">DaggerUserComponent.builder()</span><br><span class="line">	  .subjectModule(mSubjectModule)</span><br><span class="line">	  .build().injectTo(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ClassRoom mClassRoom;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubjectModule</span><span class="params">(ClassRoom classRoom)</span></span>&#123;</span><br><span class="line">	mClassRoom = classRoom;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="annotation">@Provides</span> <span class="function">Subject <span class="title">provideSubject</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Subject(mClassRoom);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//也可以给出对外接口</span></span><br><span class="line"><span class="comment">//public void setClassRoom(ClassRoom classRoom)&#123;</span></span><br><span class="line">   <span class="comment">//    this.mClassRoom = classRoom;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以上就是关于 <code>Dagger</code>  在面对多层依赖的简单情况下，生成代码的分析</p>
<p>其中关于 <code>@Module</code> <code>@Provides</code> 两个注解是关键部分，一个标注当前类是<code>Module</code>，一个标注的函数会生成<code>xxxModule_providexxxFactory</code> 从而为 <code>Component</code> 注入提供实例。</p>
<p>然后附上<code>Component</code> <code>Module</code> 和被注入类的整体关系图，因为上面写的比较详细，此处就只给一个整体图了</p>
<p> <img src="http://ob9rvakdw.bkt.clouddn.com/dagger2%20%E5%AD%A6%E4%B9%A0%28%E4%BA%8C%29.png" alt="dagger2 学习(二)"></p>
<blockquote>
<p>一家之言，如有错误，轻喷。</p>
<p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A02" target="_blank" rel="external">该部分代码A</a></p>
<p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A02.1Module" target="_blank" rel="external">该部分代码B</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;之前记录了最简单的&lt;code&gt;Dagger 2&lt;/code&gt;  使用，现在记录一下面对多层依赖时的问题，同时配合 &lt;code&gt;@Module&lt;/code&gt; 进行注入的情况。&lt;/p&gt;
&lt;h3 id=&quot;A_多层依赖情况&quot;&gt;A 多层依赖情况&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dagger2 学习(一)</title>
    <link href="http://dove.im/2016/11/11/dagger2-%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://dove.im/2016/11/11/dagger2-学习-一/</id>
    <published>2016-11-11T09:39:59.000Z</published>
    <updated>2016-11-21T08:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A01" target="_blank" rel="external">该部分代码</a></p>
<p>记录一下自己的基本的认识，<code>Dagger 2</code> 的目的是为了解决依赖问题</p>
<p>当我们申明一个 <code>User mUser</code> 对象 ，此时<code>mUser</code> 并未实例化，而当我们需要实例化的时候，则需要调用<code>new User()</code></p>
<p>而使用<code>Dagger 2</code> 的时候，我们只需要 <code>@inject User mUser</code>  然后在<code>Activity</code>中调用<code>DaggerXXXX....inject(this)</code>即可(假设是Activity，也可以是其他任何类)，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@User</span> mUser;</span><br><span class="line"><span class="annotation">@ClassRoom</span> mClassRoom;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">DaggerXXXX....inject(<span class="keyword">this</span>)<span class="comment">// 只需要调用一次即可</span></span><br><span class="line">...</span><br><span class="line">mUser.get...</span><br><span class="line">mClassRomm.get...</span><br></pre></td></tr></table></figure>
<p>那为什么不直接<code>new User()</code> 呢，因为会面对一个依赖问题，而下面的例子并没有突出解决这个问题，所以暂且搁置不写，讨论到 <code>@Module</code> 时继续讨论( 面对 <code>new User(params...)</code> 时，需要其他依赖时， 配合 <code>@Module</code> 这个注解进行使用，会显得更干净)。</p>
<blockquote>
<p>下面的记录就是最简单的注入，主要搞定了 <code>new User()</code> 这类无依赖的注入问题</p>
</blockquote>
<h3 id="Dagger_2_基本使用">Dagger 2 基本使用</h3><h4 id="1-@inject_使用，_一共两种使用地方">1.<code>@inject</code> 使用， 一共两种使用地方</h4><h5 id="(1)_标记被注入的对象的构造方法">(1) 标记被注入的对象的构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="annotation">@Inject</span><span class="comment">// 标注构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="(2)_标记注入目标处">(2) 标记注入目标处</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TextView mUserAgeTv;</span><br><span class="line">    <span class="annotation">@Inject</span> User mUser;<span class="comment">// 标注注入的对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mUserAgeTv = (TextView) findViewById(R.id.user_age_tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样标注出了两个地方，一个被注入对象的构造方法，一个需要注入的对象，但是相互之间是没有关联的</p>
<p>写完这两个类，编译后，看一下生成的具体代码，验证一下</p>
<h5 id="(3)_@Inject_public_User()-_后生成的代码">(3) <code>@Inject public User()...</code> 后生成的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> User_Factory implements Factory&lt;User&gt; &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();<span class="comment">// 真正生成 User 对象的地方</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;User&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;<span class="comment">// 返还User_Factory 对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="(4)_@Inject_User_mUser_生成的代码">(4) <code>@Inject User mUser</code> 生成的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;User&gt; mUserProvider;<span class="comment">// 用来提供User对象的 Provider</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_MembersInjector</span><span class="params">(Provider&lt;User&gt; mUserProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> mUserProvider != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mUserProvider = mUserProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;MainActivity&gt; <span class="title">create</span><span class="params">(Provider&lt;User&gt; mUserProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainActivity_MembersInjector(mUserProvider);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(MainActivity instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看起来像注入的地方 调用了 userProvider 然后调用了 get</span></span><br><span class="line">    instance.mUser = mUserProvider.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectMUser</span><span class="params">(MainActivity instance, Provider&lt;User&gt; mUserProvider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个也是看起来像注入的地方 调用了 userProvider 然后调用了 get</span></span><br><span class="line">    instance.mUser = mUserProvider.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仔细看，发现两者生成的代码现在是无关的，接下来引入连接的注解</p>
</blockquote>
<h4 id="2-@Component_使用，连接上述的两个地方，进行注入">2.<code>@Component</code> 使用，连接上述的两个地方，进行注入</h4><h5 id="(1)使用">(1)使用</h5><p>加入一个新的类，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span> <span class="comment">// 注解标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectTo</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">  <span class="comment">// 注意此处方法的参数 MainActivity ，由此标记处要注入的类，而方法名其实可以是任何名字</span></span><br><span class="line">  <span class="comment">// 被 @Component 标注的类，其具体编译后生成的代码，会有具体的实现类来处理，参考下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看文档，只知道这是一个连接的，也不知道具体怎么连接的，只知道会生成一个<code>DaggerUserComponent</code> 类，生成代码在具体调用分析处，可具体参考</p>
<p>在<code>MainActivity</code>加入 <code>DaggerUserComponent.builder().build().injectTo(this)</code> 就可以注入成功，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MainActivity.java</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    TextView mUserAgeTv;</span><br><span class="line">    <span class="annotation">@Inject</span> User mUser;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mUserAgeTv = (TextView) findViewById(R.id.user_age_tv);<span class="comment">// 加入这句</span></span><br><span class="line">        DaggerUserComponent.builder().build().injectTo(<span class="keyword">this</span>);</span><br><span class="line">        mUserAgeTv.setText(<span class="string">""</span> + mUser.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="(2)那就结合调用整体，具体看下生成的代码吧">(2)那就结合调用整体，具体看下生成的代码吧</h5><p><code>DaggerUserComponent.builder().build().injectTo(this);</code></p>
<blockquote>
<p>调用主要分两条线，看注释</p>
<ul>
<li><p><code>..builder().build()</code></p>
<p>1 -&gt; 2 步骤 生成一个 <code>DaggerUserComponent</code> 对象，同时实例化出 <code>mainActivityMembersInjector</code></p>
</li>
<li><p><code>..injectTo(this);</code></p>
<p>3 步骤 是调用 <code>MainActivity_MembersInjector</code> 进行真正的注入</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">DaggerUserComponent.java</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerUserComponent</span> <span class="keyword">implements</span> <span class="title">UserComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerUserComponent</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</span><br><span class="line">    initialize(builder);<span class="comment">//2.1 初始化 builder 对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();<span class="comment">// 1. 首先生成一个 Builder 对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 2.2 关键处，它调用的是之前生成 MainActivity_MembersInjector 的 create 方法</span></span><br><span class="line">    <span class="keyword">this</span>.mainActivityMembersInjector = MainActivity_MembersInjector.create(User_Factory.create());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectTo</span><span class="params">(MainActivity mainActivity)</span> </span>&#123;<span class="comment">//3. 最后调用 injectTo 方法</span></span><br><span class="line">    <span class="comment">// 3.1 mainActivityMembersInjector 它由 2.2 转换出来</span></span><br><span class="line">    mainActivityMembersInjector.injectMembers(mainActivity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerUserComponent(<span class="keyword">this</span>);<span class="comment">//2. 生成一个 DaggerUserComponent 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，整个连接过程就出来了</p>
<p>下图中 黄色部分，就是<code>builder().build()</code> 构建出<code>MainActivity_MembersInjector</code>，中间调用了 <code>User_Factory</code> 来生成<code>mUserProvider</code></p>
<p>下图紫色部分，就是<code>injectTo()</code> 进行注入，根据构建出的<code>MainActivity_MembersInjector</code>，获取 <code>User</code> 构建的实例，进行赋值</p>
<p> <img src="http://ob9rvakdw.bkt.clouddn.com/dagger2%E5%AD%A6%E4%B9%A0%28%E4%B8%80%29.png" alt="dagger2学习(一)"></p>
<h3 id="最后">最后</h3><p>整个记录主要写了 Dagger 2 最基本的使用，处理了 <code>new User()</code> 此类操作。</p>
<p>当然这不是 <code>Dagger 2</code> 的精华部分，此处主要是为了看其生成的代码，及其基本的使用。</p>
<p>其生成的对应关系如下：</p>
<p><code>@User  mUser</code>  ===&gt; <code>User_Factory.java</code></p>
<p><code>@User public User(){}</code> ===&gt; <code>MainActivity_MembersInjector.java</code> (其中的  <code>Provider&lt;User&gt; mUserProvider</code> )</p>
<p><code>@Component UserComponent{...}</code> ===&gt; <code>DaggerUserComponent.java</code></p>
<p>其具体作用在上面的代码注释分析中已经写了，此处不重复</p>
<p>以上。</p>
<blockquote>
<p>一家之言，如有错误，轻喷。</p>
<p><a href="https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A01" target="_blank" rel="external">该部分代码</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/flyer88/LearnDagger2/tree/%E5%AD%A6%E4%B9%A01&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;该部分代码&lt;/a&gt;&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://dove.im/2016/10/07/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>http://dove.im/2016/10/07/个人简历/</id>
    <published>2016-10-07T05:44:35.000Z</published>
    <updated>2016-11-23T05:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="个人基本信息">个人基本信息</h2><p><strong>姓名:</strong> 许鹏飞 </p>
<p><strong>学校及专业</strong>: 杭州电子科技大学 软件工程学院 本科 </p>
<p><strong>工作年限:</strong> 1年零6个月 </p>
<p><strong>联系方式:</strong> flyer88xu@gmail.com </p>
<p><strong>电话:</strong> 18667009152</p>
<p><strong>性别:</strong> 男 </p>
<p><strong>年龄:</strong> 23 </p>
<p><strong>GitHub:</strong> <a href="https://github.com/flyer88" target="_blank" rel="external">https://github.com/flyer88</a> </p>
<p><strong>个人博客:</strong> <a href="https://dove.im" target="_blank" rel="external">https://dove.im</a></p>
<p><strong>期望职位:</strong> Android 开发工程师 </p>
<p><strong>期望薪资:</strong> 税前 10k+ </p>
<p><strong>期望工作地:</strong> 杭州</p>
<hr>
<h2 id="工作经历">工作经历</h2><h3 id="杭州尘埃科技有限公司_Android_开发工程师">杭州尘埃科技有限公司 Android 开发工程师</h3><pre><code>本人在杭州尘埃科技有限公司 (2015.04-2016.06)任职 Android 开发工程师,共计一年零二个月,期间参与,设计并开发三个<span class="keyword">APP</span>,具体介绍如下：
</code></pre><h4 id="1-_【云集】-_Android_客户端(2015-04-2016-06)">1. 【云集】- Android 客户端(2015.04-2016.06)</h4><ul>
<li><p><strong>项目相关介绍:</strong> 一个浏览器应用,简洁,h5 性能高于 Chrome 等浏览器。 </p>
</li>
<li><p><strong>应用地址:</strong> <a href="http://yunji.one/" target="_blank" rel="external">http://yunji.one</a></p>
</li>
<li><p><strong>主要负责的工作:</strong></p>
<p>​    菜单栏模块,浏览器菜单栏的显示及功能具体实现 ,包括页面收藏动画及功能,分享模块实现,网页 刷新前进后退,已打开的网页应用列表显示,回到应用主页功能等等。整个用户模块,包括用户登陆注册登 录,用户数据同步。设置模块,夜间模式的实现,语言切换功能。</p>
</li>
<li><p><strong>相关处理及技术细节:</strong></p>
<ol>
<li>夜间模式的实现,由于应用最初设计是不带切换主题,选择的方案又是用自带的主题切换进行夜间模 式的实现,这中间会导致 <code>Activity</code> 会重建,从而闪屏,我用了 <code>fragment</code> 替换了整个设置界面,然后截屏当前 界面,遮盖,用一个 <code>alpha</code> 动画进行缓冲,重新生成 <code>fragment</code> 从而让整个夜间模式的切换非常柔和。</li>
<li>用户模块实现,前期对于用户数据模块的设计,单例类的实现,以及后期对用户数据同步模块的重 构,设计一个通用入口,隐藏具体实现,大量的减少代码,提高其重用性。这让我对面向对象编程的有一个 更为深入的了解。</li>
<li>最后还有一个比较比较自豪的技术小细节,就是主界面底部导航小点的动画效果,用自定义 <code>view</code> 实现,重写 <code>onDraw()</code> ,用 <code>Bezier</code> 曲线画出具体的弧线,是一个很好看的动画效果。</li>
</ol>
</li>
</ul>
<h4 id="2-_【Link】-_Android_客户端(2015-06-2016-06)">2. 【Link】- Android 客户端(2015.06-2016.06)</h4><ul>
<li><p><strong>项目相关介绍:</strong></p>
<p>​    一个工具型应用,主要作用是链接一些应用操作,提高应用使用的效率,例如一键同时发送文字等内容到 QQ 好友,微信朋友圈,微博。 </p>
</li>
<li><p><strong>应用地址:</strong> <a href="http://linkapps.io" target="_blank" rel="external">http://linkapps.io</a>    </p>
</li>
<li><p><strong>主要负责的工作:</strong></p>
<p>​    几乎整个 APP 的功能实现,例举几个重要部分,主界面商店界面实现,主要处理<code>ViewPage</code>和<code>GridView</code>的冲突。然后是云任务操作模块,具体单个操作的解析以及界面的实现。最重要的云任务运行模块,具体操作的实现,操作的链接,递归的设计,整体操作嵌入,界面的动画效果,长链接的实现。</p>
</li>
<li><p><strong>相关处理及技术细节:</strong></p>
<p>​    自认为处理和设计比较有特点的模块,操作链的实现与设计。没有采用循环实现每个操作,因为每个 操作的成功失败无法判断,所以用了一个尾递归实现,操作的成功失败,决定操作链继续和停止。然后整体 的设计让每个操作以一个插件的形式插入整个链接,同时考虑到大量操作是与后台有交互的,因此需要一个<code>web</code>端的回调<code>API</code>,同时需要进行操作的错误分发处理。</p>
</li>
</ul>
<h4 id="3-_【Pero】-_Android_客户端(2016-01-2016-06)">3. 【Pero】- Android 客户端(2016.01-2016.06)</h4><ul>
<li><p><strong>应用介绍:</strong> 图片社区应用。 </p>
</li>
<li><p><strong>应用地址:</strong> <a href="http://pero.moe" target="_blank" rel="external">http://pero.moe</a></p>
</li>
<li><p><strong>主要负责工作:</strong></p>
<p>​    几乎 <code>APP</code> 所有的模块开发与设计,例举部分重要内容,大量图片加载,本地图片缓存重用。上传模块 的设计与实现,第三方支付模块(支付宝)的接入,以及界面的实现。</p>
</li>
<li><p>相关处理及技术细节:</p>
<ol>
<li>第三方图库(<code>Glide</code>)的封装,同一封装,方便后期图库的替换,对<code>glide</code>的深入使用,包括图片本地缓存的使用,图片 token 过期的处理,图片画质的处理。</li>
<li><code>MVP</code> 架构的设计,单 <code>Activity</code> ,多个 <code>fragment</code> 组合成主界面,每个 <code>fragment</code> 有一个 <code>presenter</code> ,总的 <code>activity</code> 也持有一个 <code>fragment</code> ,从而保证三方之间通信通过主 <code>Activity</code> 的 <code>presenter</code> 进行。 </li>
<li>上传模块的实现,后台上传功能的实现,该模块最大的问题是大量图片的发送,图片上限是50张,发 送图片时,并发上传时,在统计发送数量值时,需要对该值加锁,否则会使得该值错误,从而一直显示上传界面,而无法结束。</li>
</ol>
</li>
</ul>
<p>​    </p>
<h3 id="杭州火小二科技有限公司_Android_开发工程师">杭州火小二科技有限公司 Android 开发工程师</h3><p>​    本人在杭州火小二科技有限司 (2016.07-2016.09)任职 Android 开发工程师,三个月，具体项目如下：</p>
<h4 id="【火掌柜】-_Android_客户端(2016-07-2016-10)">【火掌柜】- Android 客户端(2016.07-2016.10)</h4><ul>
<li><p><strong>应用介绍:</strong> 面向B端的餐饮客户端</p>
</li>
<li><p><strong>应用地址:</strong> <a href="http://2dfire.com/twodownload.html" target="_blank" rel="external">http://2dfire.com/twodownload.html</a></p>
</li>
<li><p><strong>主要负责工作:</strong></p>
<p>​    Dagger1 到 Dagger2 的技术升级，整个项目的混淆，提高安全性，部分小功能改造</p>
</li>
<li><p>相关处理及技术细节:</p>
<ol>
<li>老项目的 Dagger1 多数都是以单例静态方式使用，所以升级不难，麻烦的是注入的时候用的是 Object，所以需要一个反射，同时配合自己用<code>python</code>写的脚本，进行代码生成</li>
<li>混淆问题在于老项目太大，开启混下后报错信息高达 4000 多行，同时由于混淆过程中，项目多个<code>module</code>之间有同包名情况，无法进行单个模块混淆，因此只能在主<code>module</code>中处理，需要极大的耐性</li>
</ol>
</li>
</ul>
<h2 id="技能点">技能点</h2><ul>
<li><strong><code>Android</code> 技能点:</strong><ol>
<li>首先数据层,熟悉主流的网络请求方案,<code>OkHttpClient</code>+<code>Retrofit</code>+<code>RxJava</code>+<code>Gson</code>,本地存储上,熟悉 常用第三方库<code>greenDao</code>,并熟悉对其封装,也熟悉原生<code>SQLite</code>使用和封装,数据解析上,熟悉<code>xml</code>和<code>json</code>的解析常用解析方案。</li>
<li>界面层,一般自定<code>view</code>都没问题,熟悉常见布局上及控件使用,包括 <code>RecycleView</code>,<code>GridView</code>,<code>ViewPager</code>等等。图片处理上,了解 <code>LurCache</code> ,使用过<code>Glide</code> 以及 <code>Fresco</code>,会做一些自定义的操作,例如本地图品缓存,画质控制等等。动画方面,常见的 <code>Property Animation</code>, <code>View Animation</code> 和<code>Drawable Animation</code> 等动画效果也较为熟悉,对 SVG 动画也在 demo 实现过。</li>
<li>架构上,了解常见的设计模式。熟悉自己构建 <code>MVP</code> 架构,在上述【Pero 项目】中已经实践过,感觉很不错,依赖什么的处 理也不错,在自己的 demo 上跑过 <code>Dagger 2</code>+<code>DataBinding</code>+<code>EventBus</code> 架构的,感觉比自己架构的好,代码简洁,正在深入看其注解生成的代码类,进行进一步掌握。了解常见的<code>dex</code>插桩类的热补丁方案。</li>
<li><code>Android</code> 的容器化上(热部署)，了解过一些常见方案,跑过一些demo。其中自己写过 <code>dynamic-load-apk</code> 的缩小版(即代理方式实现的动态加载)，<code>native hook</code>方案只跑过现成框架，<code>React-Native</code>有接入过，但不怎么会写<code>JS</code>,<code>LuaView</code>方案没有去试验过</li>
<li>有基本的网络层知识，了解<code>DNS</code>，<code>HTTPS</code>的原理，会用常见的<code>Http</code>库，开发中喜欢 <code>OkHttpClient</code> + <code>Retrofit</code></li>
<li>其他方面,熟悉常用的第三方统计和分析接入,包括友盟，<code>ShareSDK</code>,熟悉常见 <code>bug</code> 统计,熟悉用 <code>Android Studio</code> 进行代码混淆,多渠道打包等等。熟悉 <code>Android studio</code> 开发环境。</li>
</ol>
</li>
<li><strong>额外技能点:</strong><ol>
<li>开发技术上，了解一些后端知识,用 php 配合 <code>laravel</code>, 搭建过个人博客, 也偶尔会一点<code>python</code>写写脚本，正在学习<code>scala</code>，喜欢<code>scala</code>强悍的类型系统以及函数式的特性，熟悉 <code>macOS</code> 环境开发</li>
<li>设计上，喜欢<code>MD</code>设计，了解 <code>sketch</code> ,设计过自己的 毕业设计 <code>APP</code></li>
<li>合作技能，熟悉<code>git</code>，熟悉<code>tower</code>，钉钉等常用团队合作工具</li>
<li>附加技能，英语6级,配合词典无障碍阅读文档，自带梯子,熟练使用 <code>google</code> 和 <code>StackOverflow</code> 解决问题</li>
<li>最近正在学习的技能，编译原理的基础知识，<code>x86</code> 汇编的基本知识。</li>
</ol>
</li>
</ul>
<p>​    </p>
<hr>
<h2 id="自我描述">自我描述</h2><ul>
<li><p>经历上</p>
<ol>
<li>本人大三跟随大神创业,写 <code>Android</code> 约一年半,共参加杭州尘埃科技公司三个项目。整个过程中，几乎从零开始自学<code>Android</code>，在专注 <code>Android</code> 的同时，折腾过一些其他的技术，包括 <code>Android</code>上的 VR demo，<code>Linux</code>服务器的一些知识，<code>Web</code>前后端的相关知识。</li>
<li>于6月份毕业，同时辞职，7月份入职杭州火小二科技有限公司，主要技术性上的包括上述的<code>Dagger</code>升级和混淆</li>
</ol>
<p>​    3. 现在专注于 <code>Android</code> 的深入,主要是针对源码的阅读,已在计划中的包括 <code>Handler</code> 机制,<code>View</code> 的事件传递以及 <code>xml</code> 的 <code>inflate</code>，目前以及完成对 <code>inflate</code> 源码的解析，并写了一个库(虽然没人star，蛤蛤)，正在看 <code>View</code> 的事件传递。</p>
</li>
<li><p>为人上</p>
<ol>
<li>对技术充满热情，喜欢技术驱动的工作氛围，有小小的技术崇拜。</li>
<li>工作负责，学习能力强，方向明确，积极向上，不怕折腾，爱折腾。</li>
<li>与人为善，能积极融入团队，三观端正，不用技术作恶。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;个人基本信息&quot;&gt;个人基本信息&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;姓名:&lt;/strong&gt; 许鹏飞 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学校及专业&lt;/strong&gt;: 杭州电子科技大学 软件工程学院 本科 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作年限:&lt;/strong&gt; 1年零
    
    </summary>
    
    
  </entry>
  
</feed>
